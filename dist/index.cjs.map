{"mappings":"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","sources":["src/ravencoinWallet.ts","src/blockchain/sweep.ts","src/blockchain/SendManyTransaction.ts","src/Errors.ts","src/utils.ts","src/blockchain/Transaction.ts","src/getBaseCurrencyByNetwork.ts","src/getBalance.ts","src/contants.ts","src/getAssets.ts"],"sourcesContent":["import { getRPC, methods } from \"@ravenrebels/ravencoin-rpc\";\r\nimport RavencoinKey from \"@ravenrebels/ravencoin-key\";\r\nimport Signer from \"@ravenrebels/ravencoin-sign-transaction\";\r\nimport {\r\n  ChainType,\r\n  IAddressDelta,\r\n  IAddressMetaData,\r\n  IMempoolEntry,\r\n  IOptions,\r\n  ISend,\r\n  ISendManyOptions,\r\n  ISendResult,\r\n  IUTXO,\r\n  SweepResult,\r\n} from \"./Types\";\r\n\r\nimport { sweep } from \"./blockchain/sweep\";\r\nimport { Transaction } from \"./blockchain/Transaction\";\r\nimport { SendManyTransaction } from \"./blockchain/SendManyTransaction\";\r\nimport { getBaseCurrencyByNetwork } from \"./getBaseCurrencyByNetwork\";\r\nimport { getBalance } from \"./getBalance\";\r\nimport { ValidationError } from \"./Errors\";\r\nimport { getAssets } from \"./getAssets\";\r\n\r\nexport { Transaction };\r\nexport { SendManyTransaction };\r\nconst URL_MAINNET = \"https://rvn-rpc-mainnet.ting.finance/rpc\";\r\nconst URL_TESTNET = \"https://rvn-rpc-testnet.ting.finance/rpc\";\r\n\r\n//Avoid singleton (anti-pattern)\r\n//Meaning multiple instances of the wallet must be able to co-exist\r\n\r\nexport class Wallet {\r\n  rpc = getRPC(\"anonymous\", \"anonymous\", URL_MAINNET);\r\n  _mnemonic = \"\";\r\n  network: ChainType = \"rvn\";\r\n  addressObjects: Array<IAddressMetaData> = [];\r\n  receiveAddress = \"\";\r\n  changeAddress = \"\";\r\n  addressPosition = 0;\r\n  baseCurrency = \"RVN\"; //Default is RVN but it could be EVR\r\n  offlineMode = false;\r\n  setBaseCurrency(currency: string) {\r\n    this.baseCurrency = currency;\r\n  }\r\n  getBaseCurrency() {\r\n    return this.baseCurrency;\r\n  }\r\n  /**\r\n   * Sweeping a private key means to send all the funds the address holds to your your wallet.\r\n   * The private key you sweep does not become a part of your wallet.\r\n   *\r\n   * NOTE: the address you sweep needs to cointain enough RVN to pay for the transaction\r\n   *\r\n   * @param WIF the private key of the address that you want move funds from\r\n   * @returns either a string, that is the transaction id or null if there were no funds to send\r\n   */\r\n  sweep(WIF: string, onlineMode: boolean): Promise<SweepResult> {\r\n    const wallet = this;\r\n\r\n    return sweep(WIF, wallet, onlineMode);\r\n  }\r\n  getAddressObjects() {\r\n    return this.addressObjects;\r\n  }\r\n  getAddresses(): Array<string> {\r\n    const addresses = this.addressObjects.map((obj) => {\r\n      return obj.address;\r\n    });\r\n    return addresses;\r\n  }\r\n\r\n  async init(options: IOptions) {\r\n    let username = \"anonymous\";\r\n    let password = \"anonymous\";\r\n    let url = URL_MAINNET;\r\n\r\n    //VALIDATION\r\n    if (!options) {\r\n      throw Error(\"option argument is mandatory\");\r\n    }\r\n\r\n    if (options.offlineMode === true) {\r\n      this.offlineMode = true;\r\n    }\r\n    if (!options.mnemonic) {\r\n      throw Error(\"option.mnemonic is mandatory\");\r\n    }\r\n\r\n    url = options.rpc_url || url;\r\n    password = options.rpc_password || url;\r\n    username = options.rpc_username || url;\r\n\r\n    if (options.network) {\r\n      this.network = options.network;\r\n      this.setBaseCurrency(getBaseCurrencyByNetwork(options.network));\r\n    }\r\n    if (options.network === \"rvn-test\" && !options.rpc_url) {\r\n      url = URL_TESTNET;\r\n    }\r\n\r\n    this.rpc = getRPC(username, password, url);\r\n    this._mnemonic = options.mnemonic;\r\n\r\n    //Generating the hd key is slow, so we re-use the object\r\n    const hdKey = RavencoinKey.getHDKey(this.network, this._mnemonic);\r\n    const coinType = RavencoinKey.getCoinType(this.network);\r\n    const ACCOUNT = 0;\r\n\r\n    const minAmountOfAddresses = Number.isFinite(options.minAmountOfAddresses)\r\n      ? options.minAmountOfAddresses\r\n      : 0;\r\n\r\n    let doneDerivingAddresses = false;\r\n    while (doneDerivingAddresses === false) {\r\n      //We add new addresses to tempAddresses so we can check history for the last 20\r\n      const tempAddresses = [] as string[];\r\n\r\n      for (let i = 0; i < 20; i++) {\r\n        const external = RavencoinKey.getAddressByPath(\r\n          this.network,\r\n          hdKey,\r\n          `m/44'/${coinType}'/${ACCOUNT}'/0/${this.addressPosition}`\r\n        );\r\n\r\n        const internal = RavencoinKey.getAddressByPath(\r\n          this.network,\r\n          hdKey,\r\n          `m/44'/${coinType}'/${ACCOUNT}'/1/${this.addressPosition}`\r\n        );\r\n\r\n        this.addressObjects.push(external);\r\n        this.addressObjects.push(internal);\r\n        this.addressPosition++;\r\n\r\n        tempAddresses.push(external.address + \"\");\r\n        tempAddresses.push(internal.address + \"\");\r\n      }\r\n\r\n      if (\r\n        minAmountOfAddresses &&\r\n        minAmountOfAddresses >= this.addressPosition\r\n      ) {\r\n        //In case we intend to create extra addresses on startup\r\n        doneDerivingAddresses = false;\r\n      } else if (this.offlineMode === true) {\r\n        //BREAK generation of addresses and do NOT check history on the network\r\n        doneDerivingAddresses = true;\r\n      } else {\r\n        //If no history, break\r\n        doneDerivingAddresses =\r\n          false === (await this.hasHistory(tempAddresses));\r\n      }\r\n    }\r\n  }\r\n  async hasHistory(addresses: Array<string>): Promise<boolean> {\r\n    const includeAssets = true;\r\n    const obj = {\r\n      addresses,\r\n    };\r\n\r\n    const asdf = (await this.rpc(methods.getaddressbalance, [\r\n      obj,\r\n      includeAssets,\r\n    ])) as any;\r\n\r\n    //@ts-ignore\r\n    const hasReceived = Object.values(asdf).find((asset) => asset.received > 0);\r\n\r\n    return !!hasReceived;\r\n  }\r\n\r\n  async _getFirstUnusedAddress(external: boolean) {\r\n    //First, check if lastReceivedAddress\r\n    if (external === true && this.receiveAddress) {\r\n      const asdf = await this.hasHistory([this.receiveAddress]);\r\n      if (asdf === false) {\r\n        return this.receiveAddress;\r\n      }\r\n    }\r\n    if (external === false && this.changeAddress) {\r\n      const asdf = await this.hasHistory([this.changeAddress]);\r\n      if (asdf === false) {\r\n        return this.changeAddress;\r\n      }\r\n    }\r\n\r\n    //First make a list of relevant addresses, either external (even) or change (odd)\r\n    const addresses: string[] = [];\r\n\r\n    this.getAddresses().map(function (address: string, index: number) {\r\n      if (external === true && index % 2 === 0) {\r\n        addresses.push(address);\r\n      } else if (external === false && index % 2 !== 0) {\r\n        addresses.push(address);\r\n      }\r\n    });\r\n\r\n    //Use BINARY SEARCH\r\n\r\n    // Binary search implementation to find the first item with `history` set to false\r\n    const binarySearch = async (_addresses: string[]) => {\r\n      let low = 0;\r\n      let high = _addresses.length - 1;\r\n      let result = \"\";\r\n\r\n      while (low <= high) {\r\n        const mid = Math.floor((low + high) / 2);\r\n        const addy = _addresses[mid];\r\n\r\n        const hasHistory = await this.hasHistory([addy]);\r\n        if (hasHistory === false) {\r\n          result = addy;\r\n          high = mid - 1; // Continue searching towards the left\r\n        } else {\r\n          low = mid + 1; // Continue searching towards the right\r\n        }\r\n      }\r\n\r\n      return result;\r\n    };\r\n\r\n    const result = await binarySearch(addresses);\r\n\r\n    if (!result) {\r\n      //IF we have not found one, return the first address\r\n      return addresses[0];\r\n    }\r\n    if (external === true) {\r\n      this.receiveAddress = result;\r\n    } else {\r\n      this.changeAddress = result;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  async getHistory(): Promise<IAddressDelta[]> {\r\n    const assetName = \"\"; //Must be empty string, NOT \"*\"\r\n    const addresses = this.getAddresses();\r\n    const deltas = this.rpc(methods.getaddressdeltas, [\r\n      { addresses, assetName },\r\n    ]);\r\n    //@ts-ignore\r\n    const addressDeltas: IAddressDelta[] = deltas as IAddressDelta[];\r\n    return addressDeltas;\r\n  }\r\n  async getMempool(): Promise<IMempoolEntry[]> {\r\n    const method = methods.getaddressmempool;\r\n    const includeAssets = true;\r\n    const params = [{ addresses: this.getAddresses() }, includeAssets];\r\n    return this.rpc(method, params) as Promise<IMempoolEntry[]>;\r\n  }\r\n  async getReceiveAddress() {\r\n    const isExternal = true;\r\n    return this._getFirstUnusedAddress(isExternal);\r\n  }\r\n\r\n  async getChangeAddress() {\r\n    const isExternal = false;\r\n    return this._getFirstUnusedAddress(isExternal);\r\n  }\r\n  /**\r\n   *\r\n   * @param assetName if present, only return UTXOs for that asset, otherwise for all assets\r\n   * @returns UTXOs for assets\r\n   */\r\n  async getAssetUTXOs(assetName?: string): Promise<IUTXO[]> {\r\n    //If no asset name, set to wildcard, meaning all assets\r\n    const _assetName = !assetName ? \"*\" : assetName;\r\n    const chainInfo = false;\r\n    const params = [\r\n      { addresses: this.getAddresses(), chainInfo, assetName: _assetName },\r\n    ];\r\n\r\n    return this.rpc(methods.getaddressutxos, params);\r\n  }\r\n  async getUTXOs() {\r\n    return this.rpc(methods.getaddressutxos, [\r\n      { addresses: this.getAddresses() },\r\n    ]);\r\n  }\r\n\r\n  getPrivateKeyByAddress(address: string) {\r\n    const f = this.addressObjects.find((a) => a.address === address);\r\n\r\n    if (!f) {\r\n      return undefined;\r\n    }\r\n    return f.WIF;\r\n  }\r\n  async sendRawTransaction(raw: string): Promise<string> {\r\n    return this.rpc(\"sendrawtransaction\", [raw]);\r\n  }\r\n\r\n  async send(options: ISend): Promise<ISendResult> {\r\n    //ACTUAL SENDING TRANSACTION\r\n\r\n    //Important, do not swallow the exceptions/errors of createTransaction, let them fly\r\n    const sendResult: ISendResult = await this.createTransaction(options);\r\n\r\n    try {\r\n      const id = await this.rpc(\"sendrawtransaction\", [\r\n        sendResult.debug.signedTransaction,\r\n      ]);\r\n      sendResult.transactionId = id;\r\n\r\n      return sendResult;\r\n    } catch (e) {\r\n      throw new Error(\r\n        \"Error while sending, perhaps you have pending transaction? Please try again.\"\r\n      );\r\n    }\r\n  }\r\n\r\n  async sendMany({ outputs, assetName }: ISendManyOptions) {\r\n    const options = {\r\n      wallet: this,\r\n      outputs,\r\n      assetName,\r\n    };\r\n    const sendResult: ISendResult = await this.createSendManyTransaction(\r\n      options\r\n    );\r\n\r\n    //ACTUAL SENDING TRANSACTION\r\n    //Important, do not swallow the exceptions/errors of createSendManyTransaction, let them fly\r\n\r\n    try {\r\n      const id = await this.rpc(\"sendrawtransaction\", [\r\n        sendResult.debug.signedTransaction,\r\n      ]);\r\n      sendResult.transactionId = id;\r\n\r\n      return sendResult;\r\n    } catch (e) {\r\n      throw new Error(\r\n        \"Error while sending, perhaps you have pending transaction? Please try again.\"\r\n      );\r\n    }\r\n  }\r\n  /**\r\n   * Does all the heavy lifting regarding creating a SendManyTransaction\r\n   * but it does not broadcast the actual transaction.\r\n   * Perhaps the user wants to accept the transaction fee?\r\n   * @param options\r\n   * @returns An transaction that has not been broadcasted\r\n   */\r\n  async createTransaction(options: ISend): Promise<ISendResult> {\r\n    const { amount, toAddress } = options;\r\n    let { assetName } = options;\r\n\r\n    if (!assetName) {\r\n      assetName = this.baseCurrency;\r\n    }\r\n\r\n    //Validation\r\n    if (!toAddress) {\r\n      throw Error(\"Wallet.send toAddress is mandatory\");\r\n    }\r\n    if (!amount) {\r\n      throw Error(\"Wallet.send amount is mandatory\");\r\n    }\r\n    const changeAddress = await this.getChangeAddress();\r\n\r\n    if (changeAddress === toAddress) {\r\n      throw new Error(\"Change address cannot be the same as toAddress\");\r\n    }\r\n    const transaction = new Transaction({\r\n      assetName,\r\n      amount,\r\n      toAddress,\r\n      wallet: this,\r\n    });\r\n\r\n    await transaction.loadData();\r\n\r\n    const inputs = transaction.getInputs();\r\n    const outputs = await transaction.getOutputs();\r\n\r\n    const privateKeys = transaction.getPrivateKeys();\r\n\r\n    const raw = await this.rpc(\"createrawtransaction\", [inputs, outputs]);\r\n    const signed = Signer.sign(\r\n      this.network,\r\n      raw,\r\n      transaction.getUTXOs(),\r\n      privateKeys\r\n    );\r\n\r\n    //ACTUAL SENDING TRANSACTION\r\n    try {\r\n      //   const id = await this.rpc(\"sendrawtransaction\", [signed]);\r\n      const sendResult: ISendResult = {\r\n        transactionId: null,\r\n        debug: {\r\n          amount,\r\n          assetName,\r\n          fee: transaction.getFee(),\r\n          inputs,\r\n          outputs,\r\n          privateKeys,\r\n          rawUnsignedTransaction: raw,\r\n          rvnChangeAmount: transaction.getBaseCurrencyChange(),\r\n          rvnAmount: transaction.getBaseCurrencyAmount(),\r\n          signedTransaction: signed,\r\n          UTXOs: transaction.getUTXOs(),\r\n          walletMempool: transaction.getWalletMempool(),\r\n        },\r\n      };\r\n      return sendResult;\r\n    } catch (e) {\r\n      throw new Error(\r\n        \"Error while sending, perhaps you have pending transaction? Please try again.\"\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Does all the heavy lifting regarding creating a transaction\r\n   * but it does not broadcast the actual transaction.\r\n   * Perhaps the user wants to accept the transaction fee?\r\n   * @param options\r\n   * @returns An transaction that has not been broadcasted\r\n   */\r\n  async createSendManyTransaction(options: {\r\n    assetName?: string;\r\n    outputs: { [key: string]: number };\r\n  }): Promise<ISendResult> {\r\n    let { assetName } = options;\r\n\r\n    if (!assetName) {\r\n      assetName = this.baseCurrency;\r\n    }\r\n\r\n    //Validation\r\n    if (!options.outputs) {\r\n      throw Error(\"Wallet.createSendManyTransaction outputs is mandatory\");\r\n    } else if (Object.keys(options.outputs).length === 0) {\r\n      throw new ValidationError(\r\n        \"outputs is mandatory, shoud be an object with address as keys and amounts (numbers) as values\"\r\n      );\r\n    }\r\n    const changeAddress = await this.getChangeAddress();\r\n\r\n    const toAddresses = Object.keys(options.outputs);\r\n    if (toAddresses.includes(changeAddress)) {\r\n      throw new Error(\"You cannot send to your current change address\");\r\n    }\r\n    const transaction = new SendManyTransaction({\r\n      assetName,\r\n      outputs: options.outputs,\r\n      wallet: this,\r\n    });\r\n\r\n    await transaction.loadData();\r\n\r\n    const inputs = transaction.getInputs();\r\n    const outputs = await transaction.getOutputs();\r\n\r\n    const privateKeys = transaction.getPrivateKeys();\r\n\r\n    const raw = await this.rpc(\"createrawtransaction\", [inputs, outputs]);\r\n    const signed = Signer.sign(\r\n      this.network,\r\n      raw,\r\n      transaction.getUTXOs(),\r\n      privateKeys\r\n    );\r\n\r\n    try {\r\n      const sendResult: ISendResult = {\r\n        transactionId: null,\r\n        debug: {\r\n          amount: transaction.getAmount(),\r\n          assetName,\r\n          fee: transaction.getFee(),\r\n          inputs,\r\n          outputs,\r\n          privateKeys,\r\n          rawUnsignedTransaction: raw,\r\n          rvnChangeAmount: transaction.getBaseCurrencyChange(),\r\n          rvnAmount: transaction.getBaseCurrencyAmount(),\r\n          signedTransaction: signed,\r\n          UTXOs: transaction.getUTXOs(),\r\n          walletMempool: transaction.getWalletMempool(),\r\n        },\r\n      };\r\n      return sendResult;\r\n    } catch (e) {\r\n      throw new Error(\r\n        \"Error while sending, perhaps you have pending transaction? Please try again.\"\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This method checks if an UTXO is being spent in the mempool.\r\n   * rpc getaddressutxos will list available UTXOs on the chain.\r\n   * BUT an UTXO can be being spent by a transaction in mempool.\r\n   *\r\n   * @param utxo\r\n   * @returns boolean true if utxo is being spent in mempool, false if not\r\n   */\r\n  async isSpentInMempool(utxo: IUTXO) {\r\n    const details = await this.rpc(\"gettxout\", [utxo.txid, utxo.outputIndex]);\r\n    return details === null; \r\n  }\r\n  async getAssets() {\r\n    return getAssets(this, this.getAddresses());\r\n  }\r\n  async getBalance() {\r\n    const a = this.getAddresses();\r\n    return getBalance(this, a);\r\n  }\r\n  async convertMempoolEntryToUTXO(mempoolEntry: IMempoolEntry): Promise<IUTXO> {\r\n    //Mempool items might not have the script attbribute, we need it\r\n    const out = await this.rpc(\"gettxout\", [\r\n      mempoolEntry.txid,\r\n      mempoolEntry.index,\r\n      true,\r\n    ]);\r\n\r\n    const utxo = {\r\n      ...mempoolEntry,\r\n      script: out.scriptPubKey.hex,\r\n      outputIndex: mempoolEntry.index,\r\n      value: mempoolEntry.satoshis / 1e8,\r\n    };\r\n    return utxo;\r\n  }\r\n\r\n  /**\r\n   * Get list of spendable UTXOs in mempool.\r\n   * Note: a UTXO in mempool can already be \"being spent\"\r\n   * @param mempool (optional)\r\n   * @returns list of UTXOs in mempool ready to spend\r\n   */\r\n  async getUTXOsInMempool(mempool?: IMempoolEntry[]) {\r\n    //If no mempool argument, fetch mempool\r\n    let _mempool = mempool;\r\n    if (!_mempool) {\r\n      const m = await this.getMempool();\r\n      _mempool = m;\r\n    }\r\n    const mySet = new Set();\r\n    for (let item of _mempool) {\r\n      if (!item.prevtxid) {\r\n        continue;\r\n      }\r\n      const value = item.prevtxid + \"_\" + item.prevout;\r\n      mySet.add(value);\r\n    }\r\n\r\n    const spendable = _mempool.filter((item) => {\r\n      if (item.satoshis < 0) {\r\n        return false;\r\n      }\r\n      const value = item.txid + \"_\" + item.index;\r\n      return mySet.has(value) === false;\r\n    });\r\n\r\n    const utxos: IUTXO[] = [];\r\n\r\n    for (let s of spendable) {\r\n      const u = await this.convertMempoolEntryToUTXO(s);\r\n      utxos.push(u);\r\n    }\r\n    return utxos;\r\n  }\r\n}\r\n\r\nexport default {\r\n  createInstance,\r\n  getBaseCurrencyByNetwork,\r\n};\r\nexport async function createInstance(options: IOptions): Promise<Wallet> {\r\n  const wallet = new Wallet();\r\n  await wallet.init(options);\r\n  return wallet;\r\n}\r\n","import RavencoinKey, { Network } from \"@ravenrebels/ravencoin-key\";\r\nimport Signer from \"@ravenrebels/ravencoin-sign-transaction\";\r\n\r\n!!Signer.sign; //\"Idiocracy\" but prevents bundle tools such as PARCEL to strip this dependency out on build.\r\n\r\nimport { Wallet } from \"../ravencoinWallet\";\r\nimport { IInput, SweepResult } from \"../Types\";\r\nimport { shortenNumber } from \"./SendManyTransaction\";\r\n\r\n//sight rate burger maid melody slogan attitude gas account sick awful hammer\r\n//OH easter egg ;)\r\nconst WIF = \"Kz5U4Bmhrng4o2ZgwBi5PjtorCeq2dyM7axGQfdxsBSwCKi5ZfTw\";\r\n\r\n/**\r\n *\r\n * @param WIF the private key in wallet import format that you want to sweep/empty\r\n * @param wallet your wallet\r\n * @returns a string of a signed transaction, you have to broad cast it\r\n */\r\nexport async function sweep(\r\n  WIF: string,\r\n  wallet: Wallet,\r\n  onlineMode: boolean\r\n): Promise<SweepResult> {\r\n  const privateKey = RavencoinKey.getAddressByWIF(wallet.network, WIF);\r\n\r\n  const result: SweepResult = {};\r\n  const rpc = wallet.rpc;\r\n  const obj = {\r\n    addresses: [privateKey.address],\r\n  };\r\n  const baseCurrencyUTXOs = await rpc(\"getaddressutxos\", [obj]);\r\n  const obj2 = {\r\n    addresses: [privateKey.address],\r\n    assetName: \"*\",\r\n  };\r\n\r\n  const assetUTXOs = await rpc(\"getaddressutxos\", [obj2]);\r\n  const UTXOs = assetUTXOs.concat(baseCurrencyUTXOs);\r\n  result.UTXOs = UTXOs;\r\n  //Create a raw transaction with ALL UTXOs\r\n\r\n  if (UTXOs.length === 0) {\r\n    result.errorDescription = \"Address \" + privateKey.address + \" has no funds\";\r\n    return result;\r\n  }\r\n  const balanceObject = {};\r\n\r\n  UTXOs.map((utxo) => {\r\n    if (!balanceObject[utxo.assetName]) {\r\n      balanceObject[utxo.assetName] = 0;\r\n    }\r\n    balanceObject[utxo.assetName] += utxo.satoshis;\r\n  });\r\n\r\n  const keys = Object.keys(balanceObject);\r\n\r\n  //Start simple, get the first addresses from the wallet\r\n\r\n  const outputs = {};\r\n\r\n  const fixedFee = 0.02; // should do for now\r\n  keys.map((assetName, index) => {\r\n    const address = wallet.getAddresses()[index];\r\n    const amount = balanceObject[assetName] / 1e8;\r\n\r\n    if (assetName === wallet.baseCurrency) {\r\n      outputs[address] = shortenNumber(amount - fixedFee);\r\n    } else {\r\n      outputs[address] = {\r\n        transfer: {\r\n          [assetName]: amount,\r\n        },\r\n      };\r\n    }\r\n  });\r\n  result.outputs = outputs;\r\n\r\n  //Convert from UTXO format to INPUT fomat\r\n  const inputs: Array<IInput> = UTXOs.map((utxo, index) => {\r\n    /*   {\r\n         \"txid\":\"id\",                      (string, required) The transaction id\r\n         \"vout\":n,                         (number, required) The output number\r\n         \"sequence\":n                      (number, optional) The sequence number\r\n       } \r\n       */\r\n\r\n    const input: IInput = {\r\n      txid: utxo.txid,\r\n      vout: utxo.outputIndex,\r\n    };\r\n    return input;\r\n  });\r\n  //Create raw transaction\r\n  const rawHex = await rpc(\"createrawtransaction\", [inputs, outputs]);\r\n\r\n  const privateKeys = {\r\n    [privateKey.address]: WIF,\r\n  };\r\n  const signedHex = Signer.sign(wallet.network, rawHex, UTXOs, privateKeys);\r\n  result.rawTransaction = signedHex;\r\n  if (onlineMode === true) {\r\n    result.transactionId = await rpc(\"sendrawtransaction\", [signedHex]);\r\n  }\r\n\r\n  return result;\r\n}\r\n","import { InsufficientFundsError, ValidationError } from \"../Errors\";\r\nimport { Wallet } from \"../ravencoinWallet\";\r\nimport {\r\n  IForcedUTXO,\r\n  IMempoolEntry,\r\n  ISendManyTransactionOptions,\r\n  IUTXO,\r\n} from \"../Types\";\r\nimport { removeDuplicates } from \"../utils\";\r\n/**\r\n * SendManyTransaction Class\r\n *\r\n * This class is responsible for calculating the necessary steps to broadcast a Ravencoin transaction:\r\n * 1) Identify available UTXOs that are not already spent in the mempool.\r\n * 2) Determine the required number of UTXOs for creating this transaction.\r\n * 3) Define the transaction's inputs and outputs.\r\n * 4) Sign the transaction.\r\n *\r\n * Note: this class does not do the actual broadcasting; it is up to the user.\r\n *\r\n * How does it work?\r\n * 1) Create an instance:\r\n *    const transaction = new SendManyTransaction({\r\n *      assetName,\r\n *      outputs: options.outputs,\r\n *      wallet: this,\r\n *    });\r\n *\r\n * 2) Load data from the network:\r\n *    transaction.loadData();\r\n */\r\n\r\nexport class SendManyTransaction {\r\n  _allUTXOs: IUTXO[]; //all UTXOs that we know of\r\n\r\n  private assetName: string;\r\n  feerate = 1; //When loadData is called, this attribute is updated from the blockchain  wallet = null;\r\n\r\n  private wallet: Wallet;\r\n  private outputs: any;\r\n  private walletMempool: IMempoolEntry[] = [];\r\n  private forcedUTXOs: IForcedUTXO[] = [];\r\n  private forcedChangeAddressBaseCurrency: string | undefined = \"\";\r\n  private forcedChangeAddressAssets: string | undefined = \"\";\r\n  constructor(options: ISendManyTransactionOptions) {\r\n    const { wallet, outputs, assetName } = options;\r\n    this.assetName = !assetName ? wallet.baseCurrency : assetName;\r\n    this.wallet = wallet;\r\n    this.outputs = outputs;\r\n    this.forcedChangeAddressAssets = options.forcedChangeAddressAssets;\r\n    this.forcedChangeAddressBaseCurrency =\r\n      options.forcedChangeAddressBaseCurrency;\r\n    //Tag forced UTXOs with the \"force\" flag\r\n    if (options.forcedUTXOs) {\r\n      options.forcedUTXOs.map((f) => (f.utxo.forced = true));\r\n      this.forcedUTXOs = options.forcedUTXOs;\r\n    }\r\n  }\r\n  /**\r\n   *\r\n   * @returns forced UTXOs for this transaction, that means \"no matter want, spend this UTXO\"\r\n   */\r\n  getForcedUTXOs() {\r\n    return this.forcedUTXOs;\r\n  }\r\n  getWalletMempool() {\r\n    return this.walletMempool;\r\n  }\r\n  getSizeInKB() {\r\n    const utxos = this.predictUTXOs();\r\n    const assumedSizePerUTXO = 300;\r\n    const assumedSizePerOutput = 100;\r\n\r\n    const bytes =\r\n      (utxos.length + 1) * assumedSizePerUTXO +\r\n      Object.keys(this.outputs).length * assumedSizePerOutput;\r\n\r\n    const kb = bytes / 1024;\r\n\r\n    return kb;\r\n  }\r\n  async loadData() {\r\n    //Load blockchain information async, and wait for it\r\n    const mempoolPromise = this.wallet.getMempool();\r\n    const assetUTXOsPromise = this.wallet.getAssetUTXOs();\r\n    const baseCurencyUTXOsPromise = this.wallet.getUTXOs();\r\n    const feeRatePromise = this.getFeeRate();\r\n\r\n    this.walletMempool = await mempoolPromise;\r\n    const assetUTXOs = await assetUTXOsPromise;\r\n    const baseCurrencyUTXOs = await baseCurencyUTXOsPromise;\r\n    this.feerate = await feeRatePromise;\r\n\r\n    const mempoolUTXOs = await this.wallet.getUTXOsInMempool(\r\n      this.walletMempool\r\n    );\r\n\r\n    const _allUTXOsTemp = assetUTXOs\r\n      .concat(baseCurrencyUTXOs)\r\n      .concat(mempoolUTXOs);\r\n\r\n    //add forced UTXO to the beginning of the array\r\n    //method getUTXOs will remove all duplicates\r\n    if (this.forcedUTXOs) {\r\n      for (let f of this.forcedUTXOs) {\r\n        const utxo = f.utxo;\r\n        _allUTXOsTemp.unshift(utxo);\r\n      }\r\n    }\r\n\r\n    //Collect UTXOs that are not currently being spent in the mempool\r\n    const allUTXOs = _allUTXOsTemp.filter((utxo) => {\r\n      //Always include forced UTXOs\r\n      if (utxo.forced === true) {\r\n        return true;\r\n      }\r\n      const objInMempool = this.walletMempool.find((mempoolEntry) => {\r\n        if (mempoolEntry.prevtxid) {\r\n          const result =\r\n            mempoolEntry.prevtxid === utxo.txid &&\r\n            mempoolEntry.prevout === utxo.outputIndex;\r\n\r\n          return result;\r\n        }\r\n        return false;\r\n      });\r\n\r\n      return !objInMempool;\r\n    });\r\n    //Sort utxos lowest first\r\n    const sorted = allUTXOs.sort(sortBySatoshis);\r\n\r\n    //Remove duplicates, like if we have added an UTXO as forced, but it is already\r\n    //in the wallet as a normal UTXO\r\n    this._allUTXOs = removeDuplicates(sorted);\r\n  }\r\n  getAmount() {\r\n    let total = 0;\r\n\r\n    const values: number[] = Object.values(this.outputs);\r\n    values.map((value) => (total += value));\r\n\r\n    return total;\r\n  }\r\n  getUTXOs(): IUTXO[] {\r\n    //NOTE, if we have FORCED utxos, they have to be included no matter what\r\n\r\n    let result: IUTXO[] = [];\r\n    if (this.isAssetTransfer() === true) {\r\n      const assetAmount = this.getAmount();\r\n      const baseCurrencyAmount = this.getBaseCurrencyAmount();\r\n      const baseCurrencyUTXOs = getEnoughUTXOs(\r\n        this._allUTXOs,\r\n        this.wallet.baseCurrency,\r\n        baseCurrencyAmount\r\n      );\r\n      const assetUTXOs = getEnoughUTXOs(\r\n        this._allUTXOs,\r\n        this.assetName,\r\n        assetAmount\r\n      );\r\n\r\n      result = assetUTXOs.concat(baseCurrencyUTXOs);\r\n    } else {\r\n      result = getEnoughUTXOs(\r\n        this._allUTXOs,\r\n        this.wallet.baseCurrency,\r\n        this.getBaseCurrencyAmount()\r\n      );\r\n    }\r\n\r\n    return result;\r\n  }\r\n  /*\r\n  Check the blockchain, network.\r\n  Is this transaction still valid? Will it be accepted?\r\n  */\r\n  validate() {}\r\n  predictUTXOs() {\r\n    let utxos: IUTXO[] = [];\r\n\r\n    if (this.isAssetTransfer()) {\r\n      utxos = getEnoughUTXOs(this._allUTXOs, this.assetName, this.getAmount());\r\n    } else {\r\n      utxos = getEnoughUTXOs(\r\n        this._allUTXOs,\r\n        this.wallet.baseCurrency,\r\n        this.getAmount()\r\n      );\r\n    }\r\n\r\n    return utxos;\r\n  }\r\n  getBaseCurrencyAmount() {\r\n    const fee = this.getFee();\r\n\r\n    if (this.isAssetTransfer() === true) {\r\n      return fee;\r\n    } else return this.getAmount() + fee;\r\n  }\r\n  getBaseCurrencyChange() {\r\n    const enoughUTXOs = getEnoughUTXOs(\r\n      this._allUTXOs,\r\n      this.wallet.baseCurrency,\r\n      this.getBaseCurrencyAmount()\r\n    );\r\n\r\n    let total = 0;\r\n    for (let utxo of enoughUTXOs) {\r\n      if (utxo.assetName !== this.wallet.baseCurrency) {\r\n        continue;\r\n      }\r\n      total = total + utxo.satoshis / 1e8;\r\n    }\r\n\r\n    const result = total - this.getBaseCurrencyAmount();\r\n\r\n    return shortenNumber(result);\r\n  }\r\n  getAssetChange() {\r\n    const enoughUTXOs = getEnoughUTXOs(\r\n      this._allUTXOs,\r\n      this.assetName,\r\n      this.getAmount()\r\n    );\r\n    let total = 0;\r\n    for (let utxo of enoughUTXOs) {\r\n      if (utxo.assetName !== this.assetName) {\r\n        continue;\r\n      }\r\n      total = total + utxo.satoshis / 1e8;\r\n    }\r\n    return total - this.getAmount();\r\n  }\r\n  isAssetTransfer() {\r\n    return this.assetName !== this.wallet.baseCurrency;\r\n  }\r\n\r\n  async getOutputs() {\r\n    //we take the declared outputs and add change outputs\r\n    const totalOutputs = {};\r\n    const changeAddressBaseCurrency =\r\n      this.forcedChangeAddressBaseCurrency ||\r\n      (await this.wallet.getChangeAddress());\r\n\r\n    if (this.isAssetTransfer() === true) {\r\n      //Validate: change address cant be toAddress\r\n      const toAddresses = Object.keys(this.outputs);\r\n      if (toAddresses.includes(changeAddressBaseCurrency) === true) {\r\n        throw new ValidationError(\r\n          \"Change address cannot be the same as to address\"\r\n        );\r\n      }\r\n      totalOutputs[changeAddressBaseCurrency] = this.getBaseCurrencyChange();\r\n      const changeAddressAsset = await this._getChangeAddressAssets();\r\n      //Validate change address can never be the same as toAddress\r\n      if (toAddresses.includes(changeAddressAsset) === true) {\r\n        throw new ValidationError(\r\n          \"Change address cannot be the same as to address\"\r\n        );\r\n      }\r\n      if (this.getAssetChange() > 0) {\r\n        totalOutputs[changeAddressAsset] = {\r\n          transfer: {\r\n            [this.assetName]: this.getAssetChange(),\r\n          },\r\n        };\r\n      }\r\n\r\n      for (let addy of Object.keys(this.outputs)) {\r\n        const amount = this.outputs[addy];\r\n        totalOutputs[addy] = {\r\n          transfer: {\r\n            [this.assetName]: amount,\r\n          },\r\n        };\r\n      }\r\n    } else {\r\n      for (let addy of Object.keys(this.outputs)) {\r\n        const amount = this.outputs[addy];\r\n        totalOutputs[addy] = amount;\r\n      }\r\n\r\n      totalOutputs[changeAddressBaseCurrency] = this.getBaseCurrencyChange();\r\n    }\r\n    return totalOutputs;\r\n  }\r\n\r\n  async _getChangeAddressAssets() {\r\n    if (this.forcedChangeAddressAssets) {\r\n      return this.forcedChangeAddressAssets;\r\n    }\r\n    const changeAddressBaseCurrency = await this.wallet.getChangeAddress();\r\n    const index = this.wallet.getAddresses().indexOf(changeAddressBaseCurrency);\r\n    const changeAddressAsset = this.wallet.getAddresses()[index + 2];\r\n    return changeAddressAsset;\r\n  }\r\n  getInputs() {\r\n    return this.getUTXOs().map((obj) => {\r\n      return { address: obj.address, txid: obj.txid, vout: obj.outputIndex };\r\n    });\r\n  }\r\n\r\n  getPrivateKeys() {\r\n    const addressObjects = this.wallet.getAddressObjects();\r\n    const privateKeys = {};\r\n    for (let u of this.getUTXOs()) {\r\n      //Find the address object (we want the WIF) for the address related to the UTXO\r\n      const addressObject = addressObjects.find(\r\n        (obj) => obj.address === u.address\r\n      );\r\n      if (addressObject) {\r\n        privateKeys[u.address] = addressObject.WIF;\r\n      }\r\n    }\r\n\r\n    //Add privatekeys from forcedUTXOs\r\n    this.forcedUTXOs.map((f) => (privateKeys[f.address] = f.privateKey));\r\n    return privateKeys;\r\n  }\r\n\r\n  getFee() {\r\n    const kb = this.getSizeInKB();\r\n\r\n    const result = kb * this.feerate;\r\n\r\n    return result;\r\n  }\r\n  async getFeeRate() {\r\n    const defaultFee = 0.02;\r\n    try {\r\n      const confirmationTarget = 20;\r\n      const asdf = await this.wallet.rpc(\"estimatesmartfee\", [\r\n        confirmationTarget,\r\n      ]);\r\n      if (!asdf.errors) {\r\n        return asdf.feerate;\r\n      } else {\r\n        return defaultFee;\r\n      }\r\n    } catch (e) {\r\n      //Might occure errors on testnet when calculating fees\r\n      return defaultFee;\r\n    }\r\n  }\r\n}\r\n\r\n//Return the number with max 2 decimals\r\nexport function shortenNumber(number) {\r\n  return parseFloat(number.toFixed(2));\r\n}\r\n\r\nfunction sortBySatoshis(u1: IUTXO, u2: IUTXO) {\r\n  if (u1.satoshis > u2.satoshis) {\r\n    return 1;\r\n  }\r\n  if (u1.satoshis === u2.satoshis) {\r\n    return 0;\r\n  }\r\n  return -1;\r\n}\r\n\r\nfunction getEnoughUTXOs(\r\n  utxos: IUTXO[],\r\n  asset: string,\r\n  amount: number\r\n): IUTXO[] {\r\n  const result: IUTXO[] = [];\r\n  let sum = 0;\r\n\r\n  if (!utxos) {\r\n    throw Error(\"getEnoughUTXOs cannot be called without utxos\");\r\n  }\r\n  //First off, add mandatory/forced UTXO, no matter what\r\n  for (let u of utxos) {\r\n    if (u.forced === true) {\r\n      if (u.assetName === asset) {\r\n        const value = u.satoshis / 1e8;\r\n        result.push(u);\r\n        sum = sum + value;\r\n      }\r\n    }\r\n  }\r\n\r\n  //Process NON FORCED utxos\r\n  for (let u of utxos) {\r\n    if (u.forced) {\r\n      continue;\r\n    }\r\n    if (sum > amount) {\r\n      break;\r\n    }\r\n    if (u.assetName !== asset) {\r\n      continue;\r\n    }\r\n    //Ignore UTXOs with zero satoshis, seems to occure when assets are minted\r\n    if (u.satoshis === 0) {\r\n      continue;\r\n    }\r\n    const value = u.satoshis / 1e8;\r\n    result.push(u);\r\n    sum = sum + value;\r\n  }\r\n\r\n  if (sum < amount) {\r\n    const error = new InsufficientFundsError(\r\n      \"You do not have \" + amount + \" \" + asset + \" you only have \" + sum\r\n    );\r\n    throw error;\r\n  }\r\n  return result;\r\n}\r\n","export class ValidationError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = \"ValidationError\";\r\n  }\r\n}\r\nexport class InvalidAddressError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = \"InvalidAddressError\";\r\n  }\r\n}\r\n\r\nexport class InsufficientFundsError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = \"InsufficientFundsError\";\r\n  }\r\n}\r\n","import { IUTXO } from \"./Types\";\r\n\r\nexport function removeDuplicates(originalArray: IUTXO[]) {\r\n  const uniqueArray: IUTXO[] = [];\r\n  const seen = new Set();\r\n\r\n  originalArray.forEach((item: IUTXO) => {\r\n    const uniqueIdentifier = item.txid + item.outputIndex;\r\n\r\n    if (!seen.has(uniqueIdentifier)) {\r\n      seen.add(uniqueIdentifier);\r\n      uniqueArray.push(item);\r\n    }\r\n  });\r\n\r\n  return uniqueArray;\r\n}\r\n","import { IMempoolEntry, ISendManyTransactionOptions, ITransactionOptions, IUTXO } from \"../Types\";\r\nimport { SendManyTransaction } from \"./SendManyTransaction\";\r\n\r\nexport class Transaction {\r\n  private sendManyTransaction: SendManyTransaction;\r\n\r\n  constructor({ wallet, toAddress, amount, assetName }: ITransactionOptions) {\r\n    const options: ISendManyTransactionOptions = {\r\n      assetName,\r\n      wallet,\r\n      outputs: {\r\n        [toAddress]: amount,\r\n      },\r\n    };\r\n    this.sendManyTransaction = new SendManyTransaction(options);\r\n  }\r\n  getWalletMempool():IMempoolEntry[] {\r\n    return this.sendManyTransaction.getWalletMempool();\r\n  }\r\n  getSizeInKB() {\r\n    return this.sendManyTransaction.getSizeInKB();\r\n  }\r\n  async loadData() {\r\n    return this.sendManyTransaction.loadData();\r\n  }\r\n  getUTXOs():IUTXO[] {\r\n    return this.sendManyTransaction.getUTXOs();\r\n  }\r\n\r\n  predictUTXOs() {\r\n    return this.sendManyTransaction.predictUTXOs();\r\n  }\r\n  getBaseCurrencyAmount() {\r\n    return this.sendManyTransaction.getBaseCurrencyAmount();\r\n  }\r\n  getBaseCurrencyChange() {\r\n    return this.sendManyTransaction.getBaseCurrencyChange();\r\n  }\r\n  getAssetChange() {\r\n    return this.sendManyTransaction.getAssetChange();\r\n  }\r\n  isAssetTransfer() {\r\n    return this.sendManyTransaction.isAssetTransfer();\r\n  }\r\n\r\n  async getOutputs() {\r\n    return this.sendManyTransaction.getOutputs();\r\n  }\r\n\r\n  getInputs() {\r\n    return this.sendManyTransaction.getInputs();\r\n  }\r\n\r\n  getPrivateKeys() {\r\n    return this.sendManyTransaction.getPrivateKeys();\r\n  }\r\n\r\n  getFee() {\r\n    return this.sendManyTransaction.getFee();\r\n  }\r\n  async getFeeRate() {\r\n    return this.sendManyTransaction.getFeeRate();\r\n  }\r\n}\r\n","import { ChainType } from \"./Types\";\r\n\r\n\r\nexport function getBaseCurrencyByNetwork(network: ChainType): string {\r\n  const map = {\r\n    evr: \"EVR\",\r\n    \"evr-test\": \"EVR\",\r\n    rvn: \"RVN\",\r\n    \"rvn-test\": \"RVN\",\r\n  };\r\n  return map[network];\r\n}\r\n","import { methods } from \"@ravenrebels/ravencoin-rpc\";\r\nimport { ONE_FULL_COIN } from \"./contants\";\r\nimport { Wallet } from \"./ravencoinWallet\";\r\n\r\nexport async function getBalance(wallet:Wallet, addresses: string[]) {\r\n  const includeAssets = false;\r\n  const params = [{ addresses }, includeAssets];\r\n  const balance = (await wallet.rpc(methods.getaddressbalance, params)) as any;\r\n\r\n  return balance.balance / ONE_FULL_COIN;\r\n}\r\n","export const ONE_FULL_COIN = 1e8;","import { methods } from \"@ravenrebels/ravencoin-rpc\";\r\nimport { Wallet } from \"./ravencoinWallet\";\r\n\r\nexport async function getAssets(wallet:Wallet, addresses: string[]) {\r\n  const includeAssets = true;\r\n  const params = [{ addresses: addresses }, includeAssets];\r\n  const balance = (await wallet.rpc(methods.getaddressbalance, params)) as any;\r\n\r\n  //Remove baseCurrency\r\n  const result = balance.filter((obj) => {\r\n    return obj.assetName !== wallet.baseCurrency;\r\n  });\r\n  return result;\r\n}\r\n"],"names":[],"version":3,"file":"index.cjs.map"}