{"mappings":"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","sources":["src/ravencoinWallet.ts","src/contants.ts","src/blockchain/sweep.ts","src/blockchain/Transaction.ts","src/Errors.ts","src/blockchain/SendManyTransaction.ts"],"sourcesContent":["import { getRPC, methods } from \"@ravenrebels/ravencoin-rpc\";\nimport RavencoinKey from \"@ravenrebels/ravencoin-key\";\nimport Signer from \"@ravenrebels/ravencoin-sign-transaction\";\nimport {\n  ChainType,\n  IAddressDelta,\n  IAddressMetaData,\n  ISend,\n  ISendManyOptions,\n  ISendResult,\n  IUTXO,\n  SweepResult,\n} from \"./Types\";\nimport { ONE_FULL_COIN } from \"./contants\";\n\nimport { sweep } from \"./blockchain/sweep\";\nimport { Transaction } from \"./blockchain/Transaction\";\nimport { SendManyTransaction } from \"./blockchain/SendManyTransaction\";\n\nconst URL_MAINNET = \"https://rvn-rpc-mainnet.ting.finance/rpc\";\nconst URL_TESTNET = \"https://rvn-rpc-testnet.ting.finance/rpc\";\n\n//Avoid singleton (anti-pattern)\n//Meaning multiple instances of the wallet must be able to co-exist\n\nexport class Wallet {\n  rpc = getRPC(\"anonymous\", \"anonymous\", URL_MAINNET);\n  _mnemonic = \"\";\n  network: ChainType = \"rvn\";\n  addressObjects: Array<IAddressMetaData> = [];\n  receiveAddress = \"\";\n  changeAddress = \"\";\n  addressPosition = 0;\n  baseCurrency = \"RVN\"; //Default is RVN but it could be EVR\n  offlineMode = false;\n  setBaseCurrency(currency: string) {\n    this.baseCurrency = currency;\n  }\n  getBaseCurrency() {\n    return this.baseCurrency;\n  }\n  /**\n   * Sweeping a private key means to send all the funds the address holds to your your wallet.\n   * The private key you sweep do not become a part of your wallet.\n   *\n   * NOTE: the address you sweep needs to cointain enough RVN to pay for the transaction\n   *\n   * @param WIF the private key of the address that you want move funds from\n   * @returns either a string, that is the transaction id or null if there were no funds to send\n   */\n  sweep(WIF: string, onlineMode: boolean): Promise<SweepResult> {\n    const wallet = this;\n\n    return sweep(WIF, wallet, onlineMode);\n  }\n  getAddressObjects() {\n    return this.addressObjects;\n  }\n  getAddresses(): Array<string> {\n    const addresses = this.addressObjects.map((obj) => {\n      return obj.address;\n    });\n    return addresses;\n  }\n\n  async init(options: IOptions) {\n    let username = \"anonymous\";\n    let password = \"anonymous\";\n    let url = URL_MAINNET;\n\n    //VALIDATION\n    if (!options) {\n      throw Error(\"option argument is mandatory\");\n    }\n\n    if (options.offlineMode === true) {\n      this.offlineMode = true;\n    }\n    if (!options.mnemonic) {\n      throw Error(\"option.mnemonic is mandatory\");\n    }\n\n    url = options.rpc_url || url;\n    password = options.rpc_password || url;\n    username = options.rpc_username || url;\n\n    if (options.network) {\n      this.network = options.network;\n      this.setBaseCurrency(getBaseCurrencyByNetwork(options.network));\n    }\n    if (options.network === \"rvn-test\" && !options.rpc_url) {\n      url = URL_TESTNET;\n    }\n\n    this.rpc = getRPC(username, password, url);\n    this._mnemonic = options.mnemonic;\n\n    //Generating the hd key is slow, so we re-use the object\n    const hdKey = RavencoinKey.getHDKey(this.network, this._mnemonic);\n    const coinType = RavencoinKey.getCoinType(this.network);\n    const ACCOUNT = 0;\n\n    //DERIVE ADDRESSES BIP44, external 20 unused (that is no history, not no balance)\n    /*\n    if (options.minAmountOfAddresses) {\n      for (let i = 0; i < options.minAmountOfAddresses; i++) {\n        const o = RavencoinKey.getAddressPair(\n          this.network,\n          this._mnemonic,\n          ACCOUNT,\n          this.addressPosition\n        );\n        this.addressObjects.push(o.external);\n        this.addressObjects.push(o.internal);\n        this.addressPosition++;\n      }\n    }\n\n    */\n    const minAmountOfAddresses = Number.isFinite(options.minAmountOfAddresses)\n      ? options.minAmountOfAddresses\n      : 0;\n\n    let doneDerivingAddresses = false;\n    while (doneDerivingAddresses === false) {\n      //We add new addresses to tempAddresses so we can check history for the last 20\n      const tempAddresses = [] as string[];\n\n      for (let i = 0; i < 20; i++) {\n        const external = RavencoinKey.getAddressByPath(\n          this.network,\n          hdKey,\n          `m/44'/${coinType}'/${ACCOUNT}'/0/${this.addressPosition}`\n        );\n\n        const internal = RavencoinKey.getAddressByPath(\n          this.network,\n          hdKey,\n          `m/44'/${coinType}'/${ACCOUNT}'/1/${this.addressPosition}`\n        );\n\n        this.addressObjects.push(external);\n        this.addressObjects.push(internal);\n        this.addressPosition++;\n\n        tempAddresses.push(external.address + \"\");\n        tempAddresses.push(internal.address + \"\");\n      }\n\n      if (\n        minAmountOfAddresses &&\n        minAmountOfAddresses >= this.addressPosition\n      ) {\n        //In case we intend to create extra addresses on startup\n\n        doneDerivingAddresses = false;\n      } else if (this.offlineMode === true) {\n        //BREAK generation of addresses and do NOT check history on the network\n        doneDerivingAddresses = true;\n      } else {\n        //If no history, break\n        doneDerivingAddresses =\n          false === (await this.hasHistory(tempAddresses));\n      }\n    }\n  }\n  async hasHistory(addresses: Array<string>): Promise<boolean> {\n    const includeAssets = true;\n    const obj = {\n      addresses,\n    };\n\n    const asdf = (await this.rpc(methods.getaddressbalance, [\n      obj,\n      includeAssets,\n    ])) as any;\n\n    //@ts-ignore\n    const hasReceived = Object.values(asdf).find((asset) => asset.received > 0);\n\n    return !!hasReceived;\n  }\n\n  async _getFirstUnusedAddress(external: boolean) {\n    //First, check if lastReceivedAddress\n    if (external === true && this.receiveAddress) {\n      const asdf = await this.hasHistory([this.receiveAddress]);\n      if (asdf === false) {\n        return this.receiveAddress;\n      }\n    }\n    if (external === false && this.changeAddress) {\n      const asdf = await this.hasHistory([this.changeAddress]);\n      if (asdf === false) {\n        return this.changeAddress;\n      }\n    }\n\n    //First make a list of relevant addresses, either external (even) or change (odd)\n    const addresses: string[] = [];\n\n    this.getAddresses().map(function (address: string, index: number) {\n      if (external === true && index % 2 === 0) {\n        addresses.push(address);\n      } else if (external === false && index % 2 !== 0) {\n        addresses.push(address);\n      }\n    });\n\n    //Use BINARY SEARCH\n\n    // Binary search implementation to find the first item with `history` set to false\n    const binarySearch = async (_addresses: string[]) => {\n      let low = 0;\n      let high = _addresses.length - 1;\n      let result = \"\";\n\n      while (low <= high) {\n        const mid = Math.floor((low + high) / 2);\n        const addy = _addresses[mid];\n\n        const hasHistory = await this.hasHistory([addy]);\n        if (hasHistory === false) {\n          result = addy;\n          high = mid - 1; // Continue searching towards the left\n        } else {\n          low = mid + 1; // Continue searching towards the right\n        }\n      }\n\n      return result;\n    };\n\n    const result = await binarySearch(addresses);\n\n    if (!result) {\n      //IF we have not found one, return the first address\n      return addresses[0];\n    }\n    if (external === true) {\n      this.receiveAddress = result;\n    } else {\n      this.changeAddress = result;\n    }\n\n    return result;\n    /*\n    //even addresses are external, odd address are internal/changes\n    for (let counter = 0; counter < addresses.length; counter++) {\n      //Internal addresses should be even numbers\n      if (external && counter % 2 !== 0) {\n        continue;\n      }\n      //Internal addresses should be odd numbers\n      if (external === false && counter % 2 === 0) {\n        continue;\n      }\n      const address = addresses[counter];\n\n      //If an address has tenth of thousands of transactions, getHistory will throw an exception\n\n      const hasHistory = await this.hasHistory([address]);\n\n      if (hasHistory === false) {\n        if (external === true) {\n          this.receiveAddress = address;\n        }\n        if (external === false) {\n          this.changeAddress = address;\n        }\n        return address;\n      }\n    }\n*/\n  }\n\n  async getHistory(): Promise<IAddressDelta[]> {\n    const assetName = \"\"; //Must be empty string, NOT \"*\"\n    const addresses = this.getAddresses();\n    const deltas = this.rpc(methods.getaddressdeltas, [\n      { addresses, assetName },\n    ]);\n    //@ts-ignore\n    const addressDeltas: IAddressDelta[] = deltas as IAddressDelta[];\n    return addressDeltas;\n  }\n  async getMempool(): Promise<IAddressDelta[]> {\n    const method = methods.getaddressmempool;\n    const includeAssets = true;\n    const params = [{ addresses: this.getAddresses() }, includeAssets];\n    return this.rpc(method, params) as Promise<IAddressDelta[]>;\n  }\n  async getReceiveAddress() {\n    const isExternal = true;\n    return this._getFirstUnusedAddress(isExternal);\n  }\n\n  async getChangeAddress() {\n    const isExternal = false;\n    return this._getFirstUnusedAddress(isExternal);\n  }\n  /**\n   *\n   * @param assetName if present, only return UTXOs for that asset, otherwise for all assets\n   * @returns UTXOs for assets\n   */\n  async getAssetUTXOs(assetName?: string): Promise<IUTXO[]> {\n    //If no asset name, set to wildcard, meaning all assets\n    const _assetName = !assetName ? \"*\" : assetName;\n    const chainInfo = false;\n    const params = [\n      { addresses: this.getAddresses(), chainInfo, assetName: _assetName },\n    ];\n\n    return this.rpc(methods.getaddressutxos, params);\n  }\n  async getUTXOs() {\n    return this.rpc(methods.getaddressutxos, [\n      { addresses: this.getAddresses() },\n    ]);\n  }\n\n  getPrivateKeyByAddress(address: string) {\n    const f = this.addressObjects.find((a) => a.address === address);\n\n    if (!f) {\n      return undefined;\n    }\n    return f.WIF;\n  }\n\n  async send(options: ISend): Promise<ISendResult> {\n    //ACTUAL SENDING TRANSACTION\n\n    //Important, do not swallow the exceptions/errors of createTransaction, let them fly\n    const sendResult: ISendResult = await this.createTransaction(options);\n\n    try {\n      const id = await this.rpc(\"sendrawtransaction\", [\n        sendResult.debug.signedTransaction,\n      ]);\n      sendResult.transactionId = id;\n\n      return sendResult;\n    } catch (e) {\n      throw new Error(\n        \"Error while sending, perhaps you have pending transaction? Please try again.\"\n      );\n    }\n  }\n  async sendRawTransaction(raw: string): Promise<string> {\n    return this.rpc(\"sendrawtransaction\", [raw]);\n  }\n\n  async sendMany({ outputs, assetName }: ISendManyOptions) {\n    const options = {\n      wallet: this,\n      outputs,\n      assetName,\n    };\n    const sendManyTransaction = new SendManyTransaction(options);\n\n    return sendManyTransaction;\n  }\n  /**\n   * Does all the heavy lifting regarding creating a transaction\n   * but it does not broadcast the actual transaction.\n   * Perhaps the user wants to accept the transaction fee?\n   * @param options\n   * @returns An transaction that has not been broadcasted\n   */\n  async createTransaction(options: ISend): Promise<ISendResult> {\n    const { amount, toAddress } = options;\n    let { assetName } = options;\n\n    if (!assetName) {\n      assetName = this.baseCurrency;\n    }\n\n    //Validation\n    if (!toAddress) {\n      throw Error(\"Wallet.send toAddress is mandatory\");\n    }\n    if (!amount) {\n      throw Error(\"Wallet.send amount is mandatory\");\n    }\n    const changeAddress = await this.getChangeAddress();\n\n    if (changeAddress === toAddress) {\n      throw new Error(\"Change address cannot be the same as toAddress\");\n    }\n    const transaction = new Transaction({\n      assetName,\n      amount,\n      toAddress,\n      wallet: this,\n    });\n\n    await transaction.loadData();\n\n    const inputs = transaction.getInputs();\n    const outputs = await transaction.getOutputs();\n\n    const privateKeys = transaction.getPrivateKeys();\n\n    const raw = await this.rpc(\"createrawtransaction\", [inputs, outputs]);\n    const signed = Signer.sign(\n      this.network,\n      raw,\n      transaction.getUTXOs(),\n      privateKeys\n    );\n\n    //ACTUAL SENDING TRANSACTION\n    try {\n      //   const id = await this.rpc(\"sendrawtransaction\", [signed]);\n      const sendResult: ISendResult = {\n        transactionId: null,\n        debug: {\n          amount,\n          assetName,\n          fee: transaction.getFee(),\n          inputs,\n          outputs,\n          privateKeys,\n          rawUnsignedTransaction: raw,\n          rvnChangeAmount: transaction.getBaseCurrencyChange(),\n          rvnAmount: transaction.getBaseCurrencyAmount(),\n          signedTransaction: signed,\n          UTXOs: transaction.getUTXOs(),\n        },\n      };\n      return sendResult;\n    } catch (e) {\n      throw new Error(\n        \"Error while sending, perhaps you have pending transaction? Please try again.\"\n      );\n    }\n  }\n\n  async getAssets() {\n    const includeAssets = true;\n    const params = [{ addresses: this.getAddresses() }, includeAssets];\n    const balance = (await this.rpc(methods.getaddressbalance, params)) as any;\n\n    //Remove baseCurrency\n    const result = balance.filter((obj) => {\n      return obj.assetName !== this.baseCurrency;\n    });\n    return result;\n  }\n  async getBalance() {\n    const includeAssets = false;\n    const params = [{ addresses: this.getAddresses() }, includeAssets];\n    const balance = (await this.rpc(methods.getaddressbalance, params)) as any;\n\n    return balance.balance / ONE_FULL_COIN;\n  }\n}\n\nexport default {\n  createInstance,\n};\nexport async function createInstance(options: IOptions): Promise<Wallet> {\n  const wallet = new Wallet();\n  await wallet.init(options);\n  return wallet;\n}\n\nexport function getBaseCurrencyByNetwork(network: ChainType): string {\n  const map = {\n    evr: \"EVR\",\n    \"evr-test\": \"EVR\",\n    rvn: \"RVN\",\n    \"rvn-test\": \"RVN\",\n  };\n  return map[network];\n}\nexport interface IOptions {\n  mnemonic: string;\n  minAmountOfAddresses?: number;\n  network?: ChainType;\n  rpc_username?: string;\n  rpc_password?: string;\n  rpc_url?: string;\n\n  offlineMode?: boolean;\n}\n","export const ONE_FULL_COIN = 1e8;","import RavencoinKey, { Network } from \"@ravenrebels/ravencoin-key\";\nimport Signer from \"@ravenrebels/ravencoin-sign-transaction\";\n\n!!Signer.sign; //\"Idiocracy\" but prevents bundle tools such as PARCEL to strip this dependency out on build.\n\nimport { Wallet } from \"../ravencoinWallet\";\nimport { IInput, SweepResult } from \"../Types\";\nimport { shortenNumber } from \"./Transaction\";\n\n//sight rate burger maid melody slogan attitude gas account sick awful hammer\n//OH easter egg ;)\nconst WIF = \"Kz5U4Bmhrng4o2ZgwBi5PjtorCeq2dyM7axGQfdxsBSwCKi5ZfTw\";\n\n/**\n *\n * @param WIF the private key in wallet import format that you want to sweep/empty\n * @param wallet your wallet\n * @returns a string of a signed transaction, you have to broad cast it\n */\nexport async function sweep(\n  WIF: string,\n  wallet: Wallet,\n  onlineMode: boolean\n): Promise<SweepResult> {\n  const privateKey = RavencoinKey.getAddressByWIF(wallet.network, WIF);\n\n  const result: SweepResult = {};\n  const rpc = wallet.rpc;\n  const obj = {\n    addresses: [privateKey.address],\n  };\n  const baseCurrencyUTXOs = await rpc(\"getaddressutxos\", [obj]);\n  const obj2 = {\n    addresses: [privateKey.address],\n    assetName: \"*\",\n  };\n\n  const assetUTXOs = await rpc(\"getaddressutxos\", [obj2]);\n  const UTXOs = assetUTXOs.concat(baseCurrencyUTXOs);\n  result.UTXOs = UTXOs;\n  //Create a raw transaction with ALL UTXOs\n\n  if (UTXOs.length === 0) {\n    result.errorDescription = \"Address \" + privateKey.address + \" has no funds\";\n    return result;\n  }\n  const balanceObject = {};\n\n  UTXOs.map((utxo) => {\n    if (!balanceObject[utxo.assetName]) {\n      balanceObject[utxo.assetName] = 0;\n    }\n    balanceObject[utxo.assetName] += utxo.satoshis;\n  });\n\n  const keys = Object.keys(balanceObject);\n\n  //Start simple, get the first addresses from the wallet\n\n  const outputs = {};\n\n  const fixedFee = 0.02; // should do for now\n  keys.map((assetName, index) => {\n    const address = wallet.getAddresses()[index];\n    const amount = balanceObject[assetName] / 1e8;\n\n    if (assetName === wallet.baseCurrency) {\n      outputs[address] = shortenNumber(amount - fixedFee);\n    } else {\n      outputs[address] = {\n        transfer: {\n          [assetName]: amount,\n        },\n      };\n    }\n  });\n  result.outputs = outputs;\n\n  //Convert from UTXO format to INPUT fomat\n  const inputs: Array<IInput> = UTXOs.map((utxo, index) => {\n    /*   {\n         \"txid\":\"id\",                      (string, required) The transaction id\n         \"vout\":n,                         (number, required) The output number\n         \"sequence\":n                      (number, optional) The sequence number\n       } \n       */\n\n    const input: IInput = {\n      txid: utxo.txid,\n      vout: utxo.outputIndex,\n    };\n    return input;\n  });\n  //Create raw transaction\n  const rawHex = await rpc(\"createrawtransaction\", [inputs, outputs]);\n\n  const privateKeys = {\n    [privateKey.address]: WIF,\n  };\n  const signedHex = Signer.sign(wallet.network, rawHex, UTXOs, privateKeys);\n  result.rawTransaction = signedHex;\n  if (onlineMode === true) {\n    result.transactionId = await rpc(\"sendrawtransaction\", [signedHex]);\n  }\n\n  return result;\n}\n","import { InsufficientFundsError, ValidationError } from \"../Errors\";\nimport { Wallet } from \"../ravencoinWallet\";\nimport { IUTXO } from \"../Types\";\n\nexport class Transaction {\n  _allUTXOs: IUTXO[]; //all UTXOs that we know of\n  amount = 0;\n  private assetName: string;\n\n  feerate = 1; //When loadData is called, this attribute is updated from the blockchain  wallet = null;\n  private toAddress: string;\n  private wallet: Wallet;\n\n  constructor({ wallet, toAddress, amount, assetName }) {\n    this.toAddress = toAddress;\n    this.amount = amount;\n    this.assetName = !assetName ? wallet.baseCurrency : assetName;\n    this.wallet = wallet;\n  }\n\n  getSizeInKB() {\n    const length = this.getUTXOs().length;\n    //Lets assume every input is 300 bytes.\n    return (length * 300) / 1000;\n  }\n  async loadData() {\n    //Load blockchain information async, and wait for it\n    const mempoolPromise = this.wallet.getMempool();\n    const assetUTXOsPromise = this.wallet.getAssetUTXOs();\n    const baseCurencyUTXOsPromise = this.wallet.getUTXOs();\n    const feeRatePromise = this.getFeeRate();\n\n    const walletMempool = await mempoolPromise;\n    const assetUTXOs = await assetUTXOsPromise;\n    const baseCurrencyUTXOs = await baseCurencyUTXOsPromise;\n    this.feerate = await feeRatePromise;\n\n    const mempoolUTXOs = getSpendableMempool(walletMempool);\n\n    //Decorate mempool UTXOs with script attribute\n    for (let u of mempoolUTXOs) {\n      if (u.script) {\n        continue;\n      }\n      //Mempool items might not have the script attbribute, we need it\n      const utxo = await this.wallet.rpc(\"gettxout\", [u.txid, u.index, true]);\n      if (utxo) {\n        u.script = utxo.scriptPubKey.hex;\n      }\n    }\n\n    const _allUTXOsTemp = assetUTXOs\n      .concat(baseCurrencyUTXOs)\n      .concat(mempoolUTXOs);\n\n    //Filter out UTXOs that are NOT in mempool\n    const allUTXOs = _allUTXOsTemp.filter((utxo) => {\n      const objInMempool = walletMempool.find(\n        (mempoolEntry) =>\n          mempoolEntry.prevtxid && mempoolEntry.prevtxid === utxo.id\n      ); \n      return !objInMempool;\n    });\n\n    //Sort utxos lowest first\n    allUTXOs.sort(sortBySatoshis);\n    this._allUTXOs = allUTXOs;\n  }\n  getUTXOs() {\n    if (this.isAssetTransfer() === true) {\n      const assetAmount = this.amount;\n      const baseCurrencyAmount = this.getBaseCurrencyAmount();\n\n      const baseCurrencyUTXOs = getEnoughUTXOs(\n        this._allUTXOs,\n        this.wallet.baseCurrency,\n        baseCurrencyAmount\n      );\n      const assetUTXOs = getEnoughUTXOs(\n        this._allUTXOs,\n        this.assetName,\n        assetAmount\n      );\n\n      return assetUTXOs.concat(baseCurrencyUTXOs);\n    } else {\n      return getEnoughUTXOs(\n        this._allUTXOs,\n        this.wallet.baseCurrency,\n        this.getBaseCurrencyAmount()\n      );\n    }\n  }\n\n  predictUTXOs() {\n    if (this.isAssetTransfer()) {\n      return getEnoughUTXOs(this._allUTXOs, this.assetName, this.amount);\n    }\n    return getEnoughUTXOs(\n      this._allUTXOs,\n      this.wallet.baseCurrency,\n      this.amount\n    );\n  }\n  getBaseCurrencyAmount() {\n    const fee = this.getFee();\n    if (this.isAssetTransfer() === true) {\n      return fee;\n    } else return this.amount + fee;\n  }\n  getBaseCurrencyChange() {\n    const enoughUTXOs = getEnoughUTXOs(\n      this._allUTXOs,\n      this.wallet.baseCurrency,\n      this.getBaseCurrencyAmount()\n    );\n\n    let total = 0;\n    for (let utxo of enoughUTXOs) {\n      if (utxo.assetName !== this.wallet.baseCurrency) {\n        continue;\n      }\n      total = total + utxo.satoshis / 1e8;\n    }\n    const result = total - this.getBaseCurrencyAmount();\n    return shortenNumber(result);\n  }\n  getAssetChange() {\n    const enoughUTXOs = getEnoughUTXOs(\n      this._allUTXOs,\n      this.assetName,\n      this.amount\n    );\n    let total = 0;\n    for (let utxo of enoughUTXOs) {\n      if (utxo.assetName !== this.assetName) {\n        continue;\n      }\n      total = total + utxo.satoshis / 1e8;\n    }\n    return total - this.amount;\n  }\n  isAssetTransfer() {\n    return this.assetName !== this.wallet.baseCurrency;\n  }\n\n  async getOutputs() {\n    const outputs = {};\n    if (this.isAssetTransfer() === true) {\n      const changeAddressBaseCurrency = await this.wallet.getChangeAddress();\n\n      //Validate: change address cant be toAddress\n      if (changeAddressBaseCurrency === this.toAddress) {\n        throw new ValidationError(\n          \"Change address cannot be the same as toAddress\"\n        );\n      }\n      outputs[changeAddressBaseCurrency] = this.getBaseCurrencyChange();\n\n      const index = this.wallet\n        .getAddresses()\n        .indexOf(changeAddressBaseCurrency);\n      const changeAddressAsset = this.wallet.getAddresses()[index + 2];\n      //Validate change address can never be the same as toAddress\n      if (changeAddressAsset === this.toAddress) {\n        throw new ValidationError(\n          \"Change address cannot be the same as toAddress\"\n        );\n      }\n      if (this.getAssetChange() > 0) {\n        outputs[changeAddressAsset] = {\n          transfer: {\n            [this.assetName]: this.getAssetChange(),\n          },\n        };\n      }\n      outputs[this.toAddress] = {\n        transfer: {\n          [this.assetName]: this.amount,\n        },\n      };\n    } else {\n      const changeAddressBaseCurrency = await this.wallet.getChangeAddress();\n      outputs[this.toAddress] = this.amount;\n      outputs[changeAddressBaseCurrency] = this.getBaseCurrencyChange();\n    }\n    return outputs;\n  }\n\n  getInputs() {\n    return this.getUTXOs().map((obj) => {\n      return { address: obj.address, txid: obj.txid, vout: obj.outputIndex };\n    });\n  }\n\n  getPrivateKeys() {\n    const addressObjects = this.wallet.getAddressObjects();\n    const privateKeys = {};\n    for (let u of this.getUTXOs()) {\n      //Find the address object (we want the WIF) for the address related to the UTXO\n      const addressObject = addressObjects.find(\n        (obj) => obj.address === u.address\n      );\n      if (addressObject) {\n        privateKeys[u.address] = addressObject.WIF;\n      }\n    }\n    return privateKeys;\n  }\n\n  getFee() {\n    const utxos = this.predictUTXOs();\n\n    const assumedSizePerUTXO = 300;\n    const bytes = (utxos.length + 1) * assumedSizePerUTXO;\n    const kb = bytes / 1024;\n    const result = kb * this.feerate;\n\n    return result;\n  }\n  async getFeeRate() {\n    const defaultFee = 0.02;\n    try {\n      const confirmationTarget = 20;\n      const asdf = await this.wallet.rpc(\"estimatesmartfee\", [\n        confirmationTarget,\n      ]);\n      if (!asdf.errors) {\n        return asdf.feerate;\n      } else {\n        return defaultFee;\n      }\n    } catch (e) {\n      //Might occure errors on testnet when calculating fees\n      return defaultFee;\n    }\n  }\n}\n\n//Return the number with max 2 decimals\nexport function shortenNumber(number) {\n  return parseFloat(number.toFixed(2));\n}\n\nfunction sortBySatoshis(u1, u2) {\n  if (u1.satoshis > u2.satoshis) {\n    return 1;\n  }\n  if (u1.satoshis === u2.satoshis) {\n    return 0;\n  }\n  return -1;\n}\n\nfunction getEnoughUTXOs(\n  utxos: IUTXO[],\n  asset: string,\n  amount: number\n): IUTXO[] {\n  const result: IUTXO[] = [];\n  let sum = 0;\n  for (let u of utxos) {\n    if (sum > amount) {\n      break;\n    }\n    if (u.assetName !== asset) {\n      continue;\n    }\n    //Ignore UTXOs with zero satoshis, seems to occure when assets are minted\n    if (u.satoshis === 0) {\n      continue;\n    }\n    const value = u.satoshis / 1e8;\n    result.push(u);\n    sum = sum + value;\n  }\n\n  if (sum < amount) {\n    const error = new InsufficientFundsError(\n      \"You do not have \" + amount + \" \" + asset\n    );\n\n    throw error;\n  }\n  return result;\n}\n\nfunction getSpendableMempool(mempool) {\n  /*\ninterface IUTXO {\n   address: string;\n   assetName: string;\n   txid: string;\n   outputIndex: number;\n   script: string;\n   satoshis: number;\n   height: number;\n   value: number;\n}\n*/\n\n  const mySet = new Set();\n\n  for (let item of mempool) {\n    if (!item.prevtxid) {\n      continue;\n    }\n    const value = item.prevtxid + \"_\" + item.prevout;\n    mySet.add(value);\n  }\n\n  const spendable = mempool.filter((item) => {\n    if (item.satoshis < 0) {\n      return false;\n    }\n    const value = item.txid + \"_\" + item.index;\n    return mySet.has(value) === false;\n  });\n\n  //UTXO object need to have an outputIndex property, not index\n  spendable.map((s) => (s.outputIndex = s.index));\n  return spendable;\n}\n","export class ValidationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"ValidationError\";\n  }\n}\nexport class InvalidAddressError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"InvalidAddressError\";\n  }\n}\n\nexport class InsufficientFundsError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"InsufficientFundsError\";\n  }\n}\n","import { InsufficientFundsError, ValidationError } from \"../Errors\";\nimport { Wallet } from \"../ravencoinWallet\";\nimport { IUTXO } from \"../Types\";\n\nexport class SendManyTransaction {\n  _allUTXOs: IUTXO[]; //all UTXOs that we know of\n\n  private assetName: string;\n\n  feerate = 1; //When loadData is called, this attribute is updated from the blockchain  wallet = null;\n\n  private wallet: Wallet;\n  private outputs: any;\n  constructor({ wallet, outputs, assetName }) {\n    this.assetName = !assetName ? wallet.baseCurrency : assetName;\n    this.wallet = wallet;\n    this.outputs = outputs;\n  }\n\n  getSizeInKB() {\n    const length = this.getUTXOs().length;\n    //Lets assume every input is 300 bytes.\n    return (length * 300) / 1000;\n  }\n  async loadData() {\n    //Load blockchain information async, and wait for it\n    const mempoolPromise = this.wallet.getMempool();\n    const assetUTXOsPromise = this.wallet.getAssetUTXOs();\n    const baseCurencyUTXOsPromise = this.wallet.getUTXOs();\n    const feeRatePromise = this.getFeeRate();\n\n    const walletMempool = await mempoolPromise;\n    const assetUTXOs = await assetUTXOsPromise;\n    const baseCurrencyUTXOs = await baseCurencyUTXOsPromise;\n    this.feerate = await feeRatePromise;\n\n    const mempoolUTXOs = getSpendableMempool(walletMempool);\n\n    //Decorate mempool UTXOs with script attribute\n    for (let u of mempoolUTXOs) {\n      if (u.script) {\n        continue;\n      }\n      //Mempool items might not have the script attbribute, we need it\n      const utxo = await this.wallet.rpc(\"gettxout\", [u.txid, u.index, true]);\n      if (utxo) {\n        u.script = utxo.scriptPubKey.hex;\n      }\n    }\n\n    const _allUTXOsTemp = assetUTXOs\n      .concat(baseCurrencyUTXOs)\n      .concat(mempoolUTXOs);\n\n    //Filter out UTXOs that are NOT in mempool\n    const allUTXOs = _allUTXOsTemp.filter((utxo) => {\n      const objInMempool = walletMempool.find(\n        (mempoolEntry) =>\n          mempoolEntry.prevtxid && mempoolEntry.prevtxid === utxo.id\n      );\n      return !objInMempool;\n    });\n\n    //Sort utxos lowest first\n    allUTXOs.sort(sortBySatoshis);\n    this._allUTXOs = allUTXOs;\n  }\n  getAmount() {\n    let total = 0;\n\n    const values: number[] = Object.values(this.outputs);\n    values.map((value) => (total += value));\n\n    return total;\n  }\n  getUTXOs() {\n    if (this.isAssetTransfer() === true) {\n      const assetAmount = this.getAmount();\n      const baseCurrencyAmount = this.getBaseCurrencyAmount();\n\n      const baseCurrencyUTXOs = getEnoughUTXOs(\n        this._allUTXOs,\n        this.wallet.baseCurrency,\n        baseCurrencyAmount\n      );\n      const assetUTXOs = getEnoughUTXOs(\n        this._allUTXOs,\n        this.assetName,\n        assetAmount\n      );\n\n      return assetUTXOs.concat(baseCurrencyUTXOs);\n    } else {\n      return getEnoughUTXOs(\n        this._allUTXOs,\n        this.wallet.baseCurrency,\n        this.getBaseCurrencyAmount()\n      );\n    }\n  }\n\n  predictUTXOs() {\n    if (this.isAssetTransfer()) {\n      return getEnoughUTXOs(this._allUTXOs, this.assetName, this.getAmount());\n    }\n    return getEnoughUTXOs(\n      this._allUTXOs,\n      this.wallet.baseCurrency,\n      this.getAmount()\n    );\n  }\n  getBaseCurrencyAmount() {\n    const fee = this.getFee();\n    if (this.isAssetTransfer() === true) {\n      return fee;\n    } else return this.getAmount() + fee;\n  }\n  getBaseCurrencyChange() {\n    const enoughUTXOs = getEnoughUTXOs(\n      this._allUTXOs,\n      this.wallet.baseCurrency,\n      this.getBaseCurrencyAmount()\n    );\n\n    let total = 0;\n    for (let utxo of enoughUTXOs) {\n      if (utxo.assetName !== this.wallet.baseCurrency) {\n        continue;\n      }\n      total = total + utxo.satoshis / 1e8;\n    }\n    const result = total - this.getBaseCurrencyAmount();\n    return shortenNumber(result);\n  }\n  getAssetChange() {\n    const enoughUTXOs = getEnoughUTXOs(\n      this._allUTXOs,\n      this.assetName,\n      this.getAmount()\n    );\n    let total = 0;\n    for (let utxo of enoughUTXOs) {\n      if (utxo.assetName !== this.assetName) {\n        continue;\n      }\n      total = total + utxo.satoshis / 1e8;\n    }\n    return total - this.getAmount();\n  }\n  isAssetTransfer() {\n    return this.assetName !== this.wallet.baseCurrency;\n  }\n\n  async getOutputs() {\n    //we take the declared outputs and add change outputs\n    const totalOutputs = {};\n\n    if (this.isAssetTransfer() === true) {\n      const changeAddressBaseCurrency = await this.wallet.getChangeAddress();\n\n      //Validate: change address cant be toAddress\n      const toAddresses = Object.keys(this.outputs);\n      if (toAddresses.includes(changeAddressBaseCurrency) === true) {\n        throw new ValidationError(\n          \"Change address cannot be the same as to address\"\n        );\n      }\n      totalOutputs[changeAddressBaseCurrency] = this.getBaseCurrencyChange();\n\n      const index = this.wallet\n        .getAddresses()\n        .indexOf(changeAddressBaseCurrency);\n      const changeAddressAsset = this.wallet.getAddresses()[index + 2];\n      //Validate change address can never be the same as toAddress\n      if (toAddresses.includes(changeAddressAsset) === true) {\n        throw new ValidationError(\n          \"Change address cannot be the same as to address\"\n        );\n      }\n      if (this.getAssetChange() > 0) {\n        totalOutputs[changeAddressAsset] = {\n          transfer: {\n            [this.assetName]: this.getAssetChange(),\n          },\n        };\n      }\n\n      for (let addy of Object.keys(this.outputs)) {\n        const amount = this.outputs[addy];\n        totalOutputs[addy] = {\n          transfer: {\n            [this.assetName]: amount,\n          },\n        };\n      }\n    } else {\n      const changeAddressBaseCurrency = await this.wallet.getChangeAddress();\n\n      for (let addy of Object.keys(this.outputs)) {\n        const amount = this.outputs[addy];\n        totalOutputs[addy] = amount;\n      }\n\n      totalOutputs[changeAddressBaseCurrency] = this.getBaseCurrencyChange();\n    }\n    return totalOutputs;\n  }\n\n  getInputs() {\n    return this.getUTXOs().map((obj) => {\n      return { address: obj.address, txid: obj.txid, vout: obj.outputIndex };\n    });\n  }\n\n  getPrivateKeys() {\n    const addressObjects = this.wallet.getAddressObjects();\n    const privateKeys = {};\n    for (let u of this.getUTXOs()) {\n      //Find the address object (we want the WIF) for the address related to the UTXO\n      const addressObject = addressObjects.find(\n        (obj) => obj.address === u.address\n      );\n      if (addressObject) {\n        privateKeys[u.address] = addressObject.WIF;\n      }\n    }\n    return privateKeys;\n  }\n\n  getFee() {\n    const utxos = this.predictUTXOs();\n\n    const assumedSizePerUTXO = 300;\n    const bytes = (utxos.length + 1) * assumedSizePerUTXO;\n    const kb = bytes / 1024;\n    const result = kb * this.feerate;\n\n    return result;\n  }\n  async getFeeRate() {\n    const defaultFee = 0.02;\n    try {\n      const confirmationTarget = 20;\n      const asdf = await this.wallet.rpc(\"estimatesmartfee\", [\n        confirmationTarget,\n      ]);\n      if (!asdf.errors) {\n        return asdf.feerate;\n      } else {\n        return defaultFee;\n      }\n    } catch (e) {\n      //Might occure errors on testnet when calculating fees\n      return defaultFee;\n    }\n  }\n}\n\n//Return the number with max 2 decimals\nexport function shortenNumber(number) {\n  return parseFloat(number.toFixed(2));\n}\n\nfunction sortBySatoshis(u1, u2) {\n  if (u1.satoshis > u2.satoshis) {\n    return 1;\n  }\n  if (u1.satoshis === u2.satoshis) {\n    return 0;\n  }\n  return -1;\n}\n\nfunction getEnoughUTXOs(\n  utxos: IUTXO[],\n  asset: string,\n  amount: number\n): IUTXO[] {\n  const result: IUTXO[] = [];\n  let sum = 0;\n  for (let u of utxos) {\n    if (sum > amount) {\n      break;\n    }\n    if (u.assetName !== asset) {\n      continue;\n    }\n    //Ignore UTXOs with zero satoshis, seems to occure when assets are minted\n    if (u.satoshis === 0) {\n      continue;\n    }\n    const value = u.satoshis / 1e8;\n    result.push(u);\n    sum = sum + value;\n  }\n\n  if (sum < amount) {\n    const error = new InsufficientFundsError(\n      \"You do not have \" + amount + \" \" + asset\n    );\n\n    throw error;\n  }\n  return result;\n}\n\nfunction getSpendableMempool(mempool) {\n  /*\ninterface IUTXO {\n   address: string;\n   assetName: string;\n   txid: string;\n   outputIndex: number;\n   script: string;\n   satoshis: number;\n   height: number;\n   value: number;\n}\n*/\n\n  const mySet = new Set();\n\n  for (let item of mempool) {\n    if (!item.prevtxid) {\n      continue;\n    }\n    const value = item.prevtxid + \"_\" + item.prevout;\n    mySet.add(value);\n  }\n\n  const spendable = mempool.filter((item) => {\n    if (item.satoshis < 0) {\n      return false;\n    }\n    const value = item.txid + \"_\" + item.index;\n    return mySet.has(value) === false;\n  });\n\n  //UTXO object need to have an outputIndex property, not index\n  spendable.map((s) => (s.outputIndex = s.index));\n  return spendable;\n}\n"],"names":[],"version":3,"file":"index.cjs.map"}