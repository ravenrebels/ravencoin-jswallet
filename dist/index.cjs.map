{"mappings":"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","sources":["src/ravencoinWallet.ts","src/blockchain/sweep.ts","src/blockchain/SendManyTransaction.ts","src/Errors.ts","src/utils.ts","src/blockchain/Transaction.ts","src/getBaseCurrencyByNetwork.ts","src/getBalance.ts","src/contants.ts","src/getAssets.ts"],"sourcesContent":["import { getRPC, methods } from \"@ravenrebels/ravencoin-rpc\";\nimport RavencoinKey from \"@ravenrebels/ravencoin-key\";\nimport Signer from \"@ravenrebels/ravencoin-sign-transaction\";\nimport {\n  ChainType,\n  IAddressDelta,\n  IAddressMetaData,\n  IMempoolEntry,\n  IOptions,\n  ISend,\n  ISendManyOptions,\n  ISendResult,\n  IUTXO,\n  SweepResult,\n} from \"./Types\";\n\nimport { sweep } from \"./blockchain/sweep\";\nimport { Transaction } from \"./blockchain/Transaction\";\nimport { SendManyTransaction } from \"./blockchain/SendManyTransaction\";\nimport { getBaseCurrencyByNetwork } from \"./getBaseCurrencyByNetwork\";\nimport { getBalance } from \"./getBalance\";\nimport { ValidationError } from \"./Errors\";\nimport { getAssets } from \"./getAssets\";\n\nexport { Transaction };\nexport { SendManyTransaction };\nconst URL_RAVENCOIN_MAINNET = \"https://rvn-rpc-mainnet.ting.finance/rpc\";\nconst URL_RAVENCOIN_TESTNET = \"https://rvn-rpc-testnet.ting.finance/rpc\";\nconst URL_EVRMORE_MAINNET = \"https://evr-rpc-mainnet.ting.finance/rpc\";\n\n//Avoid singleton (anti-pattern)\n//Meaning multiple instances of the wallet must be able to co-exist\n\nexport class Wallet {\n  rpc = getRPC(\"anonymous\", \"anonymous\", URL_RAVENCOIN_MAINNET);\n  _mnemonic = \"\";\n  network: ChainType = \"rvn\";\n  addressObjects: Array<IAddressMetaData> = [];\n  receiveAddress = \"\";\n  changeAddress = \"\";\n  addressPosition = 0;\n  baseCurrency = \"RVN\"; //Default is RVN but it could be EVR\n  offlineMode = false;\n  setBaseCurrency(currency: string) {\n    this.baseCurrency = currency;\n  }\n  getBaseCurrency() {\n    return this.baseCurrency;\n  }\n  /**\n   * Sweeping a private key means to send all the funds the address holds to your your wallet.\n   * The private key you sweep does not become a part of your wallet.\n   *\n   * NOTE: the address you sweep needs to cointain enough RVN to pay for the transaction\n   *\n   * @param WIF the private key of the address that you want move funds from\n   * @returns either a string, that is the transaction id or null if there were no funds to send\n   */\n  sweep(WIF: string, onlineMode: boolean): Promise<SweepResult> {\n    const wallet = this;\n\n    return sweep(WIF, wallet, onlineMode);\n  }\n  getAddressObjects() {\n    return this.addressObjects;\n  }\n  getAddresses(): Array<string> {\n    const addresses = this.addressObjects.map((obj) => {\n      return obj.address;\n    });\n    return addresses;\n  }\n\n  async init(options: IOptions) {\n    let username = \"anonymous\";\n    let password = \"anonymous\";\n    let url = URL_RAVENCOIN_MAINNET;\n\n    //VALIDATION\n    if (!options) {\n      throw Error(\"option argument is mandatory\");\n    }\n\n    if (options.offlineMode === true) {\n      this.offlineMode = true;\n    }\n    if (!options.mnemonic) {\n      throw Error(\"option.mnemonic is mandatory\");\n    }\n    if (options.network === \"rvn-test\") {\n      url = URL_RAVENCOIN_TESTNET;\n    }\n    if (options.network === \"evr\") {\n      url = URL_EVRMORE_MAINNET;\n    }\n    url = options.rpc_url || url;\n    password = options.rpc_password || password;\n    username = options.rpc_username || username;\n\n    if (options.network) {\n      this.network = options.network;\n      this.setBaseCurrency(getBaseCurrencyByNetwork(options.network));\n    }\n\n    this.rpc = getRPC(username, password, url);\n    this._mnemonic = options.mnemonic;\n\n    //Generating the hd key is slow, so we re-use the object\n    const hdKey = RavencoinKey.getHDKey(this.network, this._mnemonic);\n    const coinType = RavencoinKey.getCoinType(this.network);\n    const ACCOUNT = 0;\n\n    const minAmountOfAddresses = Number.isFinite(options.minAmountOfAddresses)\n      ? options.minAmountOfAddresses\n      : 0;\n\n    let doneDerivingAddresses = false;\n    while (doneDerivingAddresses === false) {\n      //We add new addresses to tempAddresses so we can check history for the last 20\n      const tempAddresses = [] as string[];\n\n      for (let i = 0; i < 20; i++) {\n        const external = RavencoinKey.getAddressByPath(\n          this.network,\n          hdKey,\n          `m/44'/${coinType}'/${ACCOUNT}'/0/${this.addressPosition}`\n        );\n\n        const internal = RavencoinKey.getAddressByPath(\n          this.network,\n          hdKey,\n          `m/44'/${coinType}'/${ACCOUNT}'/1/${this.addressPosition}`\n        );\n\n        this.addressObjects.push(external);\n        this.addressObjects.push(internal);\n        this.addressPosition++;\n\n        tempAddresses.push(external.address + \"\");\n        tempAddresses.push(internal.address + \"\");\n      }\n\n      if (\n        minAmountOfAddresses &&\n        minAmountOfAddresses >= this.addressPosition\n      ) {\n        //In case we intend to create extra addresses on startup\n        doneDerivingAddresses = false;\n      } else if (this.offlineMode === true) {\n        //BREAK generation of addresses and do NOT check history on the network\n        doneDerivingAddresses = true;\n      } else {\n        //If no history, break\n        doneDerivingAddresses =\n          false === (await this.hasHistory(tempAddresses));\n      }\n    }\n  }\n  async hasHistory(addresses: Array<string>): Promise<boolean> {\n    const includeAssets = true;\n    const obj = {\n      addresses,\n    };\n\n    const asdf = (await this.rpc(methods.getaddressbalance, [\n      obj,\n      includeAssets,\n    ])) as any;\n\n    //@ts-ignore\n    const hasReceived = Object.values(asdf).find((asset) => asset.received > 0);\n\n    return !!hasReceived;\n  }\n\n  async _getFirstUnusedAddress(external: boolean) {\n    //First, check if lastReceivedAddress\n    if (external === true && this.receiveAddress) {\n      const asdf = await this.hasHistory([this.receiveAddress]);\n      if (asdf === false) {\n        return this.receiveAddress;\n      }\n    }\n    if (external === false && this.changeAddress) {\n      const asdf = await this.hasHistory([this.changeAddress]);\n      if (asdf === false) {\n        return this.changeAddress;\n      }\n    }\n\n    //First make a list of relevant addresses, either external (even) or change (odd)\n    const addresses: string[] = [];\n\n    this.getAddresses().map(function (address: string, index: number) {\n      if (external === true && index % 2 === 0) {\n        addresses.push(address);\n      } else if (external === false && index % 2 !== 0) {\n        addresses.push(address);\n      }\n    });\n\n    //Use BINARY SEARCH\n\n    // Binary search implementation to find the first item with `history` set to false\n    const binarySearch = async (_addresses: string[]) => {\n      let low = 0;\n      let high = _addresses.length - 1;\n      let result = \"\";\n\n      while (low <= high) {\n        const mid = Math.floor((low + high) / 2);\n        const addy = _addresses[mid];\n\n        const hasHistory = await this.hasHistory([addy]);\n        if (hasHistory === false) {\n          result = addy;\n          high = mid - 1; // Continue searching towards the left\n        } else {\n          low = mid + 1; // Continue searching towards the right\n        }\n      }\n\n      return result;\n    };\n\n    const result = await binarySearch(addresses);\n\n    if (!result) {\n      //IF we have not found one, return the first address\n      return addresses[0];\n    }\n    if (external === true) {\n      this.receiveAddress = result;\n    } else {\n      this.changeAddress = result;\n    }\n\n    return result;\n  }\n\n  async getHistory(): Promise<IAddressDelta[]> {\n    const assetName = \"\"; //Must be empty string, NOT \"*\"\n    const addresses = this.getAddresses();\n    const deltas = this.rpc(methods.getaddressdeltas, [\n      { addresses, assetName },\n    ]);\n    //@ts-ignore\n    const addressDeltas: IAddressDelta[] = deltas as IAddressDelta[];\n    return addressDeltas;\n  }\n  async getMempool(): Promise<IMempoolEntry[]> {\n    const method = methods.getaddressmempool;\n    const includeAssets = true;\n    const params = [{ addresses: this.getAddresses() }, includeAssets];\n    return this.rpc(method, params) as Promise<IMempoolEntry[]>;\n  }\n  async getReceiveAddress() {\n    const isExternal = true;\n    return this._getFirstUnusedAddress(isExternal);\n  }\n\n  async getChangeAddress() {\n    const isExternal = false;\n    return this._getFirstUnusedAddress(isExternal);\n  }\n  /**\n   *\n   * @param assetName if present, only return UTXOs for that asset, otherwise for all assets\n   * @returns UTXOs for assets\n   */\n  async getAssetUTXOs(assetName?: string): Promise<IUTXO[]> {\n    //If no asset name, set to wildcard, meaning all assets\n    const _assetName = !assetName ? \"*\" : assetName;\n    const chainInfo = false;\n    const params = [\n      { addresses: this.getAddresses(), chainInfo, assetName: _assetName },\n    ];\n\n    return this.rpc(methods.getaddressutxos, params);\n  }\n  async getUTXOs() {\n    return this.rpc(methods.getaddressutxos, [\n      { addresses: this.getAddresses() },\n    ]);\n  }\n\n  getPrivateKeyByAddress(address: string) {\n    const f = this.addressObjects.find((a) => a.address === address);\n\n    if (!f) {\n      return undefined;\n    }\n    return f.WIF;\n  }\n  async sendRawTransaction(raw: string): Promise<string> {\n    return this.rpc(\"sendrawtransaction\", [raw]);\n  }\n\n  async send(options: ISend): Promise<ISendResult> {\n    //ACTUAL SENDING TRANSACTION\n\n    //Important, do not swallow the exceptions/errors of createTransaction, let them fly\n    const sendResult: ISendResult = await this.createTransaction(options);\n\n    try {\n      const id = await this.rpc(\"sendrawtransaction\", [\n        sendResult.debug.signedTransaction,\n      ]);\n      sendResult.transactionId = id;\n\n      return sendResult;\n    } catch (e) {\n      throw new Error(\n        \"Error while sending, perhaps you have pending transaction? Please try again.\"\n      );\n    }\n  }\n\n  async sendMany({ outputs, assetName }: ISendManyOptions) {\n    const options = {\n      wallet: this,\n      outputs,\n      assetName,\n    };\n    const sendResult: ISendResult = await this.createSendManyTransaction(\n      options\n    );\n\n    //ACTUAL SENDING TRANSACTION\n    //Important, do not swallow the exceptions/errors of createSendManyTransaction, let them fly\n\n    try {\n      const id = await this.rpc(\"sendrawtransaction\", [\n        sendResult.debug.signedTransaction,\n      ]);\n      sendResult.transactionId = id;\n\n      return sendResult;\n    } catch (e) {\n      throw new Error(\n        \"Error while sending, perhaps you have pending transaction? Please try again.\"\n      );\n    }\n  }\n  /**\n   * Does all the heavy lifting regarding creating a SendManyTransaction\n   * but it does not broadcast the actual transaction.\n   * Perhaps the user wants to accept the transaction fee?\n   * @param options\n   * @returns An transaction that has not been broadcasted\n   */\n  async createTransaction(options: ISend): Promise<ISendResult> {\n    const { amount, toAddress } = options;\n    let { assetName } = options;\n\n    if (!assetName) {\n      assetName = this.baseCurrency;\n    }\n\n    //Validation\n    if (!toAddress) {\n      throw Error(\"Wallet.send toAddress is mandatory\");\n    }\n    if (!amount) {\n      throw Error(\"Wallet.send amount is mandatory\");\n    }\n    const changeAddress = await this.getChangeAddress();\n\n    if (changeAddress === toAddress) {\n      throw new Error(\"Change address cannot be the same as toAddress\");\n    }\n    const transaction = new Transaction({\n      assetName,\n      amount,\n      toAddress,\n      wallet: this,\n    });\n\n    await transaction.loadData();\n\n    const inputs = transaction.getInputs();\n    const outputs = await transaction.getOutputs();\n\n    const privateKeys = transaction.getPrivateKeys();\n\n    const raw = await this.rpc(\"createrawtransaction\", [inputs, outputs]);\n    const signed = Signer.sign(\n      this.network,\n      raw,\n      transaction.getUTXOs(),\n      privateKeys\n    );\n\n    //ACTUAL SENDING TRANSACTION\n    try {\n      //   const id = await this.rpc(\"sendrawtransaction\", [signed]);\n      const sendResult: ISendResult = {\n        transactionId: null,\n        debug: {\n          amount,\n          assetName,\n          fee: transaction.getFee(),\n          inputs,\n          outputs,\n          privateKeys,\n          rawUnsignedTransaction: raw,\n          rvnChangeAmount: transaction.getBaseCurrencyChange(),\n          rvnAmount: transaction.getBaseCurrencyAmount(),\n          signedTransaction: signed,\n          UTXOs: transaction.getUTXOs(),\n          walletMempool: transaction.getWalletMempool(),\n        },\n      };\n      return sendResult;\n    } catch (e) {\n      throw new Error(\n        \"Error while sending, perhaps you have pending transaction? Please try again.\"\n      );\n    }\n  }\n\n  /**\n   * Does all the heavy lifting regarding creating a transaction\n   * but it does not broadcast the actual transaction.\n   * Perhaps the user wants to accept the transaction fee?\n   * @param options\n   * @returns An transaction that has not been broadcasted\n   */\n  async createSendManyTransaction(options: {\n    assetName?: string;\n    outputs: { [key: string]: number };\n  }): Promise<ISendResult> {\n    let { assetName } = options;\n\n    if (!assetName) {\n      assetName = this.baseCurrency;\n    }\n\n    //Validation\n    if (!options.outputs) {\n      throw Error(\"Wallet.createSendManyTransaction outputs is mandatory\");\n    } else if (Object.keys(options.outputs).length === 0) {\n      throw new ValidationError(\n        \"outputs is mandatory, shoud be an object with address as keys and amounts (numbers) as values\"\n      );\n    }\n    const changeAddress = await this.getChangeAddress();\n\n    const toAddresses = Object.keys(options.outputs);\n    if (toAddresses.includes(changeAddress)) {\n      throw new Error(\"You cannot send to your current change address\");\n    }\n    const transaction = new SendManyTransaction({\n      assetName,\n      outputs: options.outputs,\n      wallet: this,\n    });\n\n    await transaction.loadData();\n\n    const inputs = transaction.getInputs();\n    const outputs = await transaction.getOutputs();\n\n    const privateKeys = transaction.getPrivateKeys();\n\n    const raw = await this.rpc(\"createrawtransaction\", [inputs, outputs]);\n    const signed = Signer.sign(\n      this.network,\n      raw,\n      transaction.getUTXOs(),\n      privateKeys\n    );\n\n    try {\n      const sendResult: ISendResult = {\n        transactionId: null,\n        debug: {\n          amount: transaction.getAmount(),\n          assetName,\n          fee: transaction.getFee(),\n          inputs,\n          outputs,\n          privateKeys,\n          rawUnsignedTransaction: raw,\n          rvnChangeAmount: transaction.getBaseCurrencyChange(),\n          rvnAmount: transaction.getBaseCurrencyAmount(),\n          signedTransaction: signed,\n          UTXOs: transaction.getUTXOs(),\n          walletMempool: transaction.getWalletMempool(),\n        },\n      };\n      return sendResult;\n    } catch (e) {\n      throw new Error(\n        \"Error while sending, perhaps you have pending transaction? Please try again.\"\n      );\n    }\n  }\n\n  /**\n   * This method checks if an UTXO is being spent in the mempool.\n   * rpc getaddressutxos will list available UTXOs on the chain.\n   * BUT an UTXO can be being spent by a transaction in mempool.\n   *\n   * @param utxo\n   * @returns boolean true if utxo is being spent in mempool, false if not\n   */\n  async isSpentInMempool(utxo: IUTXO) {\n    const details = await this.rpc(\"gettxout\", [utxo.txid, utxo.outputIndex]);\n    return details === null;\n  }\n  async getAssets() {\n    return getAssets(this, this.getAddresses());\n  }\n  async getBalance() {\n    const a = this.getAddresses();\n    return getBalance(this, a);\n  }\n  async convertMempoolEntryToUTXO(mempoolEntry: IMempoolEntry): Promise<IUTXO> {\n    //Mempool items might not have the script attbribute, we need it\n    const out = await this.rpc(\"gettxout\", [\n      mempoolEntry.txid,\n      mempoolEntry.index,\n      true,\n    ]);\n\n    const utxo = {\n      ...mempoolEntry,\n      script: out.scriptPubKey.hex,\n      outputIndex: mempoolEntry.index,\n      value: mempoolEntry.satoshis / 1e8,\n    };\n    return utxo;\n  }\n\n  /**\n   * Get list of spendable UTXOs in mempool.\n   * Note: a UTXO in mempool can already be \"being spent\"\n   * @param mempool (optional)\n   * @returns list of UTXOs in mempool ready to spend\n   */\n  async getUTXOsInMempool(mempool?: IMempoolEntry[]) {\n    //If no mempool argument, fetch mempool\n    let _mempool = mempool;\n    if (!_mempool) {\n      const m = await this.getMempool();\n      _mempool = m;\n    }\n    const mySet = new Set();\n    for (let item of _mempool) {\n      if (!item.prevtxid) {\n        continue;\n      }\n      const value = item.prevtxid + \"_\" + item.prevout;\n      mySet.add(value);\n    }\n\n    const spendable = _mempool.filter((item) => {\n      if (item.satoshis < 0) {\n        return false;\n      }\n      const value = item.txid + \"_\" + item.index;\n      return mySet.has(value) === false;\n    });\n\n    const utxos: IUTXO[] = [];\n\n    for (let s of spendable) {\n      const u = await this.convertMempoolEntryToUTXO(s);\n      utxos.push(u);\n    }\n    return utxos;\n  }\n}\n\nexport default {\n  createInstance,\n  getBaseCurrencyByNetwork,\n};\nexport async function createInstance(options: IOptions): Promise<Wallet> {\n  const wallet = new Wallet();\n  await wallet.init(options);\n  return wallet;\n}\n","import RavencoinKey, { Network } from \"@ravenrebels/ravencoin-key\";\nimport Signer from \"@ravenrebels/ravencoin-sign-transaction\";\n\n!!Signer.sign; //\"Idiocracy\" but prevents bundle tools such as PARCEL to strip this dependency out on build.\n\nimport { Wallet } from \"../ravencoinWallet\";\nimport { IInput, SweepResult } from \"../Types\";\nimport { shortenNumber } from \"./SendManyTransaction\";\n\n//sight rate burger maid melody slogan attitude gas account sick awful hammer\n//OH easter egg ;)\nconst WIF = \"Kz5U4Bmhrng4o2ZgwBi5PjtorCeq2dyM7axGQfdxsBSwCKi5ZfTw\";\n\n/**\n *\n * @param WIF the private key in wallet import format that you want to sweep/empty\n * @param wallet your wallet\n * @returns a string of a signed transaction, you have to broad cast it\n */\nexport async function sweep(\n  WIF: string,\n  wallet: Wallet,\n  onlineMode: boolean\n): Promise<SweepResult> {\n  const privateKey = RavencoinKey.getAddressByWIF(wallet.network, WIF);\n\n  const result: SweepResult = {};\n  const rpc = wallet.rpc;\n  const obj = {\n    addresses: [privateKey.address],\n  };\n  const baseCurrencyUTXOs = await rpc(\"getaddressutxos\", [obj]);\n  const obj2 = {\n    addresses: [privateKey.address],\n    assetName: \"*\",\n  };\n\n  const assetUTXOs = await rpc(\"getaddressutxos\", [obj2]);\n  const UTXOs = assetUTXOs.concat(baseCurrencyUTXOs);\n  result.UTXOs = UTXOs;\n  //Create a raw transaction with ALL UTXOs\n\n  if (UTXOs.length === 0) {\n    result.errorDescription = \"Address \" + privateKey.address + \" has no funds\";\n    return result;\n  }\n  const balanceObject = {};\n\n  UTXOs.map((utxo) => {\n    if (!balanceObject[utxo.assetName]) {\n      balanceObject[utxo.assetName] = 0;\n    }\n    balanceObject[utxo.assetName] += utxo.satoshis;\n  });\n\n  const keys = Object.keys(balanceObject);\n\n  //Start simple, get the first addresses from the wallet\n\n  const outputs = {};\n\n  const fixedFee = 0.02; // should do for now\n  keys.map((assetName, index) => {\n    const address = wallet.getAddresses()[index];\n    const amount = balanceObject[assetName] / 1e8;\n\n    if (assetName === wallet.baseCurrency) {\n      outputs[address] = shortenNumber(amount - fixedFee);\n    } else {\n      outputs[address] = {\n        transfer: {\n          [assetName]: amount,\n        },\n      };\n    }\n  });\n  result.outputs = outputs;\n\n  //Convert from UTXO format to INPUT fomat\n  const inputs: Array<IInput> = UTXOs.map((utxo, index) => {\n    /*   {\n         \"txid\":\"id\",                      (string, required) The transaction id\n         \"vout\":n,                         (number, required) The output number\n         \"sequence\":n                      (number, optional) The sequence number\n       } \n       */\n\n    const input: IInput = {\n      txid: utxo.txid,\n      vout: utxo.outputIndex,\n    };\n    return input;\n  });\n  //Create raw transaction\n  const rawHex = await rpc(\"createrawtransaction\", [inputs, outputs]);\n\n  const privateKeys = {\n    [privateKey.address]: WIF,\n  };\n  const signedHex = Signer.sign(wallet.network, rawHex, UTXOs, privateKeys);\n  result.rawTransaction = signedHex;\n  if (onlineMode === true) {\n    result.transactionId = await rpc(\"sendrawtransaction\", [signedHex]);\n  }\n\n  return result;\n}\n","import { InsufficientFundsError, ValidationError } from \"../Errors\";\nimport { Wallet } from \"../ravencoinWallet\";\nimport {\n  IForcedUTXO,\n  IMempoolEntry,\n  ISendManyTransactionOptions,\n  IUTXO,\n} from \"../Types\";\nimport { removeDuplicates } from \"../utils\";\n/**\n * SendManyTransaction Class\n *\n * This class is responsible for calculating the necessary steps to broadcast a Ravencoin transaction:\n * 1) Identify available UTXOs that are not already spent in the mempool.\n * 2) Determine the required number of UTXOs for creating this transaction.\n * 3) Define the transaction's inputs and outputs.\n * 4) Sign the transaction.\n *\n * Note: this class does not do the actual broadcasting; it is up to the user.\n *\n * How does it work?\n * 1) Create an instance:\n *    const transaction = new SendManyTransaction({\n *      assetName,\n *      outputs: options.outputs,\n *      wallet: this,\n *    });\n *\n * 2) Load data from the network:\n *    transaction.loadData();\n */\n\nexport class SendManyTransaction {\n  _allUTXOs: IUTXO[]; //all UTXOs that we know of\n\n  private assetName: string;\n  feerate = 1; //When loadData is called, this attribute is updated from the blockchain  wallet = null;\n\n  private wallet: Wallet;\n  private outputs: any;\n  private walletMempool: IMempoolEntry[] = [];\n  private forcedUTXOs: IForcedUTXO[] = [];\n  private forcedChangeAddressBaseCurrency: string | undefined = \"\";\n  private forcedChangeAddressAssets: string | undefined = \"\";\n  constructor(options: ISendManyTransactionOptions) {\n    const { wallet, outputs, assetName } = options;\n    this.assetName = !assetName ? wallet.baseCurrency : assetName;\n    this.wallet = wallet;\n    this.outputs = outputs;\n    this.forcedChangeAddressAssets = options.forcedChangeAddressAssets;\n    this.forcedChangeAddressBaseCurrency =\n      options.forcedChangeAddressBaseCurrency;\n    //Tag forced UTXOs with the \"force\" flag\n    if (options.forcedUTXOs) {\n      options.forcedUTXOs.map((f) => (f.utxo.forced = true));\n      this.forcedUTXOs = options.forcedUTXOs;\n    }\n  }\n  /**\n   *\n   * @returns forced UTXOs for this transaction, that means \"no matter want, spend this UTXO\"\n   */\n  getForcedUTXOs() {\n    return this.forcedUTXOs;\n  }\n  getWalletMempool() {\n    return this.walletMempool;\n  }\n  getSizeInKB() {\n    const utxos = this.predictUTXOs();\n    const assumedSizePerUTXO = 300;\n    const assumedSizePerOutput = 100;\n\n    const bytes =\n      (utxos.length + 1) * assumedSizePerUTXO +\n      Object.keys(this.outputs).length * assumedSizePerOutput;\n\n    const kb = bytes / 1024;\n\n    return kb;\n  }\n  async loadData() {\n    //Load blockchain information async, and wait for it\n    const mempoolPromise = this.wallet.getMempool();\n    const assetUTXOsPromise = this.wallet.getAssetUTXOs();\n    const baseCurencyUTXOsPromise = this.wallet.getUTXOs();\n    const feeRatePromise = this.getFeeRate();\n\n    this.walletMempool = await mempoolPromise;\n    const assetUTXOs = await assetUTXOsPromise;\n    const baseCurrencyUTXOs = await baseCurencyUTXOsPromise;\n    this.feerate = await feeRatePromise;\n\n    const mempoolUTXOs = await this.wallet.getUTXOsInMempool(\n      this.walletMempool\n    );\n\n    const _allUTXOsTemp = assetUTXOs\n      .concat(baseCurrencyUTXOs)\n      .concat(mempoolUTXOs);\n\n    //add forced UTXO to the beginning of the array\n    //method getUTXOs will remove all duplicates\n    if (this.forcedUTXOs) {\n      for (let f of this.forcedUTXOs) {\n        const utxo = f.utxo;\n        _allUTXOsTemp.unshift(utxo);\n      }\n    }\n\n    //Collect UTXOs that are not currently being spent in the mempool\n    const allUTXOs = _allUTXOsTemp.filter((utxo) => {\n      //Always include forced UTXOs\n      if (utxo.forced === true) {\n        return true;\n      }\n      const objInMempool = this.walletMempool.find((mempoolEntry) => {\n        if (mempoolEntry.prevtxid) {\n          const result =\n            mempoolEntry.prevtxid === utxo.txid &&\n            mempoolEntry.prevout === utxo.outputIndex;\n\n          return result;\n        }\n        return false;\n      });\n\n      return !objInMempool;\n    });\n    //Sort utxos lowest first\n    const sorted = allUTXOs.sort(sortBySatoshis);\n\n    //Remove duplicates, like if we have added an UTXO as forced, but it is already\n    //in the wallet as a normal UTXO\n    this._allUTXOs = removeDuplicates(sorted);\n  }\n  getAmount() {\n    let total = 0;\n\n    const values: number[] = Object.values(this.outputs);\n    values.map((value) => (total += value));\n\n    return total;\n  }\n  getUTXOs(): IUTXO[] {\n    //NOTE, if we have FORCED utxos, they have to be included no matter what\n\n    let result: IUTXO[] = [];\n    if (this.isAssetTransfer() === true) {\n      const assetAmount = this.getAmount();\n      const baseCurrencyAmount = this.getBaseCurrencyAmount();\n      const baseCurrencyUTXOs = getEnoughUTXOs(\n        this._allUTXOs,\n        this.wallet.baseCurrency,\n        baseCurrencyAmount\n      );\n      const assetUTXOs = getEnoughUTXOs(\n        this._allUTXOs,\n        this.assetName,\n        assetAmount\n      );\n\n      result = assetUTXOs.concat(baseCurrencyUTXOs);\n    } else {\n      result = getEnoughUTXOs(\n        this._allUTXOs,\n        this.wallet.baseCurrency,\n        this.getBaseCurrencyAmount()\n      );\n    }\n\n    return result;\n  }\n  /*\n  Check the blockchain, network.\n  Is this transaction still valid? Will it be accepted?\n  */\n  validate() {}\n  predictUTXOs() {\n    let utxos: IUTXO[] = [];\n\n    if (this.isAssetTransfer()) {\n      utxos = getEnoughUTXOs(this._allUTXOs, this.assetName, this.getAmount());\n    } else {\n      utxos = getEnoughUTXOs(\n        this._allUTXOs,\n        this.wallet.baseCurrency,\n        this.getAmount()\n      );\n    }\n\n    return utxos;\n  }\n  getBaseCurrencyAmount() {\n    const fee = this.getFee();\n\n    if (this.isAssetTransfer() === true) {\n      return fee;\n    } else return this.getAmount() + fee;\n  }\n  getBaseCurrencyChange() {\n    const enoughUTXOs = getEnoughUTXOs(\n      this._allUTXOs,\n      this.wallet.baseCurrency,\n      this.getBaseCurrencyAmount()\n    );\n\n    let total = 0;\n    for (let utxo of enoughUTXOs) {\n      if (utxo.assetName !== this.wallet.baseCurrency) {\n        continue;\n      }\n      total = total + utxo.satoshis / 1e8;\n    }\n\n    const result = total - this.getBaseCurrencyAmount();\n\n    return shortenNumber(result);\n  }\n  getAssetChange() {\n    const enoughUTXOs = getEnoughUTXOs(\n      this._allUTXOs,\n      this.assetName,\n      this.getAmount()\n    );\n    let total = 0;\n    for (let utxo of enoughUTXOs) {\n      if (utxo.assetName !== this.assetName) {\n        continue;\n      }\n      total = total + utxo.satoshis / 1e8;\n    }\n    return total - this.getAmount();\n  }\n  isAssetTransfer() {\n    return this.assetName !== this.wallet.baseCurrency;\n  }\n\n  async getOutputs() {\n    //we take the declared outputs and add change outputs\n    const totalOutputs = {};\n    const changeAddressBaseCurrency =\n      this.forcedChangeAddressBaseCurrency ||\n      (await this.wallet.getChangeAddress());\n\n    if (this.isAssetTransfer() === true) {\n      //Validate: change address cant be toAddress\n      const toAddresses = Object.keys(this.outputs);\n      if (toAddresses.includes(changeAddressBaseCurrency) === true) {\n        throw new ValidationError(\n          \"Change address cannot be the same as to address\"\n        );\n      }\n      totalOutputs[changeAddressBaseCurrency] = this.getBaseCurrencyChange();\n      const changeAddressAsset = await this._getChangeAddressAssets();\n      //Validate change address can never be the same as toAddress\n      if (toAddresses.includes(changeAddressAsset) === true) {\n        throw new ValidationError(\n          \"Change address cannot be the same as to address\"\n        );\n      }\n      if (this.getAssetChange() > 0) {\n        totalOutputs[changeAddressAsset] = {\n          transfer: {\n            [this.assetName]: this.getAssetChange(),\n          },\n        };\n      }\n\n      for (let addy of Object.keys(this.outputs)) {\n        const amount = this.outputs[addy];\n        totalOutputs[addy] = {\n          transfer: {\n            [this.assetName]: amount,\n          },\n        };\n      }\n    } else {\n      for (let addy of Object.keys(this.outputs)) {\n        const amount = this.outputs[addy];\n        totalOutputs[addy] = amount;\n      }\n\n      totalOutputs[changeAddressBaseCurrency] = this.getBaseCurrencyChange();\n    }\n    return totalOutputs;\n  }\n\n  async _getChangeAddressAssets() {\n    if (this.forcedChangeAddressAssets) {\n      return this.forcedChangeAddressAssets;\n    }\n    const changeAddressBaseCurrency = await this.wallet.getChangeAddress();\n    const index = this.wallet.getAddresses().indexOf(changeAddressBaseCurrency);\n    const changeAddressAsset = this.wallet.getAddresses()[index + 2];\n    return changeAddressAsset;\n  }\n  getInputs() {\n    return this.getUTXOs().map((obj) => {\n      return { address: obj.address, txid: obj.txid, vout: obj.outputIndex };\n    });\n  }\n\n  getPrivateKeys() {\n    const addressObjects = this.wallet.getAddressObjects();\n    const privateKeys = {};\n    for (let u of this.getUTXOs()) {\n      //Find the address object (we want the WIF) for the address related to the UTXO\n      const addressObject = addressObjects.find(\n        (obj) => obj.address === u.address\n      );\n      if (addressObject) {\n        privateKeys[u.address] = addressObject.WIF;\n      }\n    }\n\n    //Add privatekeys from forcedUTXOs\n    this.forcedUTXOs.map((f) => (privateKeys[f.address] = f.privateKey));\n    return privateKeys;\n  }\n\n  getFee() {\n    const kb = this.getSizeInKB();\n    const result = kb * this.feerate;\n\n    return result;\n  }\n  async getFeeRate() {\n    const defaultFee = 0.02;\n    try {\n      const confirmationTarget = 20;\n      const response = await this.wallet.rpc(\"estimatesmartfee\", [\n        confirmationTarget,\n      ]);\n      //Errors can occur on testnet, not enough info to calculate fee\n      if (!response.errors) {\n        return normaliseFee(this.wallet.network, response.feerate);\n      } else {\n        return defaultFee;\n      }\n    } catch (e) {\n      //Might occure errors on testnet when calculating fees\n      return defaultFee;\n    }\n  }\n}\n\n//Return the number with max 2 decimals\nexport function shortenNumber(number) {\n  return parseFloat(number.toFixed(2));\n}\n\nfunction sortBySatoshis(u1: IUTXO, u2: IUTXO) {\n  if (u1.satoshis > u2.satoshis) {\n    return 1;\n  }\n  if (u1.satoshis === u2.satoshis) {\n    return 0;\n  }\n  return -1;\n}\n\nfunction getEnoughUTXOs(\n  utxos: IUTXO[],\n  asset: string,\n  amount: number\n): IUTXO[] {\n  const result: IUTXO[] = [];\n  let sum = 0;\n\n  if (!utxos) {\n    throw Error(\"getEnoughUTXOs cannot be called without utxos\");\n  }\n  //First off, add mandatory/forced UTXO, no matter what\n  for (let u of utxos) {\n    if (u.forced === true) {\n      if (u.assetName === asset) {\n        const value = u.satoshis / 1e8;\n        result.push(u);\n        sum = sum + value;\n      }\n    }\n  }\n\n  //Process NON FORCED utxos\n  for (let u of utxos) {\n    if (u.forced) {\n      continue;\n    }\n    if (sum > amount) {\n      break;\n    }\n    if (u.assetName !== asset) {\n      continue;\n    }\n    //Ignore UTXOs with zero satoshis, seems to occure when assets are minted\n    if (u.satoshis === 0) {\n      continue;\n    }\n    const value = u.satoshis / 1e8;\n    result.push(u);\n    sum = sum + value;\n  }\n\n  if (sum < amount) {\n    const error = new InsufficientFundsError(\n      \"You do not have \" + amount + \" \" + asset + \" you only have \" + sum\n    );\n    throw error;\n  }\n  return result;\n}\n\nfunction normaliseFee(network: string, fee: number) {\n  //Seems to be a bug with EVR fees are 1300 times too high\n  if (network === \"evr\" && fee > 1) {\n    return fee / 100;\n  }\n  return fee;\n}\n","export class ValidationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"ValidationError\";\n  }\n}\nexport class InvalidAddressError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"InvalidAddressError\";\n  }\n}\n\nexport class InsufficientFundsError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"InsufficientFundsError\";\n  }\n}\n","import { IUTXO } from \"./Types\";\n\nexport function removeDuplicates(originalArray: IUTXO[]) {\n  const uniqueArray: IUTXO[] = [];\n  const seen = new Set();\n\n  originalArray.forEach((item: IUTXO) => {\n    const uniqueIdentifier = item.txid + item.outputIndex;\n\n    if (!seen.has(uniqueIdentifier)) {\n      seen.add(uniqueIdentifier);\n      uniqueArray.push(item);\n    }\n  });\n\n  return uniqueArray;\n}\n","import { IMempoolEntry, ISendManyTransactionOptions, ITransactionOptions, IUTXO } from \"../Types\";\nimport { SendManyTransaction } from \"./SendManyTransaction\";\n\nexport class Transaction {\n  private sendManyTransaction: SendManyTransaction;\n\n  constructor({ wallet, toAddress, amount, assetName }: ITransactionOptions) {\n    const options: ISendManyTransactionOptions = {\n      assetName,\n      wallet,\n      outputs: {\n        [toAddress]: amount,\n      },\n    };\n    this.sendManyTransaction = new SendManyTransaction(options);\n  }\n  getWalletMempool():IMempoolEntry[] {\n    return this.sendManyTransaction.getWalletMempool();\n  }\n  getSizeInKB() {\n    return this.sendManyTransaction.getSizeInKB();\n  }\n  async loadData() {\n    return this.sendManyTransaction.loadData();\n  }\n  getUTXOs():IUTXO[] {\n    return this.sendManyTransaction.getUTXOs();\n  }\n\n  predictUTXOs() {\n    return this.sendManyTransaction.predictUTXOs();\n  }\n  getBaseCurrencyAmount() {\n    return this.sendManyTransaction.getBaseCurrencyAmount();\n  }\n  getBaseCurrencyChange() {\n    return this.sendManyTransaction.getBaseCurrencyChange();\n  }\n  getAssetChange() {\n    return this.sendManyTransaction.getAssetChange();\n  }\n  isAssetTransfer() {\n    return this.sendManyTransaction.isAssetTransfer();\n  }\n\n  async getOutputs() {\n    return this.sendManyTransaction.getOutputs();\n  }\n\n  getInputs() {\n    return this.sendManyTransaction.getInputs();\n  }\n\n  getPrivateKeys() {\n    return this.sendManyTransaction.getPrivateKeys();\n  }\n\n  getFee() {\n    return this.sendManyTransaction.getFee();\n  }\n  async getFeeRate() {\n    return this.sendManyTransaction.getFeeRate();\n  }\n}\n","import { ChainType } from \"./Types\";\n\n\nexport function getBaseCurrencyByNetwork(network: ChainType): string {\n  const map = {\n    evr: \"EVR\",\n    \"evr-test\": \"EVR\",\n    rvn: \"RVN\",\n    \"rvn-test\": \"RVN\",\n  };\n  return map[network];\n}\n","import { methods } from \"@ravenrebels/ravencoin-rpc\";\nimport { ONE_FULL_COIN } from \"./contants\";\nimport { Wallet } from \"./ravencoinWallet\";\n\nexport async function getBalance(wallet:Wallet, addresses: string[]) {\n  const includeAssets = false;\n  const params = [{ addresses }, includeAssets];\n  const balance = (await wallet.rpc(methods.getaddressbalance, params)) as any;\n\n  return balance.balance / ONE_FULL_COIN;\n}\n","export const ONE_FULL_COIN = 1e8;","import { methods } from \"@ravenrebels/ravencoin-rpc\";\nimport { Wallet } from \"./ravencoinWallet\";\n\nexport async function getAssets(wallet:Wallet, addresses: string[]) {\n  const includeAssets = true;\n  const params = [{ addresses: addresses }, includeAssets];\n  const balance = (await wallet.rpc(methods.getaddressbalance, params)) as any;\n\n  //Remove baseCurrency\n  const result = balance.filter((obj) => {\n    return obj.assetName !== wallet.baseCurrency;\n  });\n  return result;\n}\n"],"names":[],"version":3,"file":"index.cjs.map"}