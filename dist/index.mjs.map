{"mappings":"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","sources":["src/ravencoinWallet.ts","src/contants.ts","src/blockchain/sweep.ts","src/blockchain/SendManyTransaction.ts","src/Errors.ts","src/blockchain/Transaction.ts"],"sourcesContent":["import { getRPC, methods } from \"@ravenrebels/ravencoin-rpc\";\r\nimport RavencoinKey from \"@ravenrebels/ravencoin-key\";\r\nimport Signer from \"@ravenrebels/ravencoin-sign-transaction\";\r\nimport {\r\n  ChainType,\r\n  IAddressDelta,\r\n  IAddressMetaData,\r\n  ISend,\r\n  ISendManyOptions,\r\n  ISendResult,\r\n  IUTXO,\r\n  SweepResult,\r\n} from \"./Types\";\r\nimport { ONE_FULL_COIN } from \"./contants\";\r\n\r\nimport { sweep } from \"./blockchain/sweep\";\r\nimport { Transaction } from \"./blockchain/Transaction\";\r\nimport { SendManyTransaction } from \"./blockchain/SendManyTransaction\";\r\n\r\nconst URL_MAINNET = \"https://rvn-rpc-mainnet.ting.finance/rpc\";\r\nconst URL_TESTNET = \"https://rvn-rpc-testnet.ting.finance/rpc\";\r\n\r\n//Avoid singleton (anti-pattern)\r\n//Meaning multiple instances of the wallet must be able to co-exist\r\n\r\nexport class Wallet {\r\n  rpc = getRPC(\"anonymous\", \"anonymous\", URL_MAINNET);\r\n  _mnemonic = \"\";\r\n  network: ChainType = \"rvn\";\r\n  addressObjects: Array<IAddressMetaData> = [];\r\n  receiveAddress = \"\";\r\n  changeAddress = \"\";\r\n  addressPosition = 0;\r\n  baseCurrency = \"RVN\"; //Default is RVN but it could be EVR\r\n  offlineMode = false;\r\n  setBaseCurrency(currency: string) {\r\n    this.baseCurrency = currency;\r\n  }\r\n  getBaseCurrency() {\r\n    return this.baseCurrency;\r\n  }\r\n  /**\r\n   * Sweeping a private key means to send all the funds the address holds to your your wallet.\r\n   * The private key you sweep do not become a part of your wallet.\r\n   *\r\n   * NOTE: the address you sweep needs to cointain enough RVN to pay for the transaction\r\n   *\r\n   * @param WIF the private key of the address that you want move funds from\r\n   * @returns either a string, that is the transaction id or null if there were no funds to send\r\n   */\r\n  sweep(WIF: string, onlineMode: boolean): Promise<SweepResult> {\r\n    const wallet = this;\r\n\r\n    return sweep(WIF, wallet, onlineMode);\r\n  }\r\n  getAddressObjects() {\r\n    return this.addressObjects;\r\n  }\r\n  getAddresses(): Array<string> {\r\n    const addresses = this.addressObjects.map((obj) => {\r\n      return obj.address;\r\n    });\r\n    return addresses;\r\n  }\r\n\r\n  async init(options: IOptions) {\r\n    let username = \"anonymous\";\r\n    let password = \"anonymous\";\r\n    let url = URL_MAINNET;\r\n\r\n    //VALIDATION\r\n    if (!options) {\r\n      throw Error(\"option argument is mandatory\");\r\n    }\r\n\r\n    if (options.offlineMode === true) {\r\n      this.offlineMode = true;\r\n    }\r\n    if (!options.mnemonic) {\r\n      throw Error(\"option.mnemonic is mandatory\");\r\n    }\r\n\r\n    url = options.rpc_url || url;\r\n    password = options.rpc_password || url;\r\n    username = options.rpc_username || url;\r\n\r\n    if (options.network) {\r\n      this.network = options.network;\r\n      this.setBaseCurrency(getBaseCurrencyByNetwork(options.network));\r\n    }\r\n    if (options.network === \"rvn-test\" && !options.rpc_url) {\r\n      url = URL_TESTNET;\r\n    }\r\n\r\n    this.rpc = getRPC(username, password, url);\r\n    this._mnemonic = options.mnemonic;\r\n\r\n    //Generating the hd key is slow, so we re-use the object\r\n    const hdKey = RavencoinKey.getHDKey(this.network, this._mnemonic);\r\n    const coinType = RavencoinKey.getCoinType(this.network);\r\n    const ACCOUNT = 0;\r\n\r\n    //DERIVE ADDRESSES BIP44, external 20 unused (that is no history, not no balance)\r\n    /*\r\n    if (options.minAmountOfAddresses) {\r\n      for (let i = 0; i < options.minAmountOfAddresses; i++) {\r\n        const o = RavencoinKey.getAddressPair(\r\n          this.network,\r\n          this._mnemonic,\r\n          ACCOUNT,\r\n          this.addressPosition\r\n        );\r\n        this.addressObjects.push(o.external);\r\n        this.addressObjects.push(o.internal);\r\n        this.addressPosition++;\r\n      }\r\n    }\r\n\r\n    */\r\n    const minAmountOfAddresses = Number.isFinite(options.minAmountOfAddresses)\r\n      ? options.minAmountOfAddresses\r\n      : 0;\r\n\r\n    let doneDerivingAddresses = false;\r\n    while (doneDerivingAddresses === false) {\r\n      //We add new addresses to tempAddresses so we can check history for the last 20\r\n      const tempAddresses = [] as string[];\r\n\r\n      for (let i = 0; i < 20; i++) {\r\n        const external = RavencoinKey.getAddressByPath(\r\n          this.network,\r\n          hdKey,\r\n          `m/44'/${coinType}'/${ACCOUNT}'/0/${this.addressPosition}`\r\n        );\r\n\r\n        const internal = RavencoinKey.getAddressByPath(\r\n          this.network,\r\n          hdKey,\r\n          `m/44'/${coinType}'/${ACCOUNT}'/1/${this.addressPosition}`\r\n        );\r\n\r\n        this.addressObjects.push(external);\r\n        this.addressObjects.push(internal);\r\n        this.addressPosition++;\r\n\r\n        tempAddresses.push(external.address + \"\");\r\n        tempAddresses.push(internal.address + \"\");\r\n      }\r\n\r\n      if (\r\n        minAmountOfAddresses &&\r\n        minAmountOfAddresses >= this.addressPosition\r\n      ) {\r\n        //In case we intend to create extra addresses on startup\r\n\r\n        doneDerivingAddresses = false;\r\n      } else if (this.offlineMode === true) {\r\n        //BREAK generation of addresses and do NOT check history on the network\r\n        doneDerivingAddresses = true;\r\n      } else {\r\n        //If no history, break\r\n        doneDerivingAddresses =\r\n          false === (await this.hasHistory(tempAddresses));\r\n      }\r\n    }\r\n  }\r\n  async hasHistory(addresses: Array<string>): Promise<boolean> {\r\n    const includeAssets = true;\r\n    const obj = {\r\n      addresses,\r\n    };\r\n\r\n    const asdf = (await this.rpc(methods.getaddressbalance, [\r\n      obj,\r\n      includeAssets,\r\n    ])) as any;\r\n\r\n    //@ts-ignore\r\n    const hasReceived = Object.values(asdf).find((asset) => asset.received > 0);\r\n\r\n    return !!hasReceived;\r\n  }\r\n\r\n  async _getFirstUnusedAddress(external: boolean) {\r\n    //First, check if lastReceivedAddress\r\n    if (external === true && this.receiveAddress) {\r\n      const asdf = await this.hasHistory([this.receiveAddress]);\r\n      if (asdf === false) {\r\n        return this.receiveAddress;\r\n      }\r\n    }\r\n    if (external === false && this.changeAddress) {\r\n      const asdf = await this.hasHistory([this.changeAddress]);\r\n      if (asdf === false) {\r\n        return this.changeAddress;\r\n      }\r\n    }\r\n\r\n    //First make a list of relevant addresses, either external (even) or change (odd)\r\n    const addresses: string[] = [];\r\n\r\n    this.getAddresses().map(function (address: string, index: number) {\r\n      if (external === true && index % 2 === 0) {\r\n        addresses.push(address);\r\n      } else if (external === false && index % 2 !== 0) {\r\n        addresses.push(address);\r\n      }\r\n    });\r\n\r\n    //Use BINARY SEARCH\r\n\r\n    // Binary search implementation to find the first item with `history` set to false\r\n    const binarySearch = async (_addresses: string[]) => {\r\n      let low = 0;\r\n      let high = _addresses.length - 1;\r\n      let result = \"\";\r\n\r\n      while (low <= high) {\r\n        const mid = Math.floor((low + high) / 2);\r\n        const addy = _addresses[mid];\r\n\r\n        const hasHistory = await this.hasHistory([addy]);\r\n        if (hasHistory === false) {\r\n          result = addy;\r\n          high = mid - 1; // Continue searching towards the left\r\n        } else {\r\n          low = mid + 1; // Continue searching towards the right\r\n        }\r\n      }\r\n\r\n      return result;\r\n    };\r\n\r\n    const result = await binarySearch(addresses);\r\n\r\n    if (!result) {\r\n      //IF we have not found one, return the first address\r\n      return addresses[0];\r\n    }\r\n    if (external === true) {\r\n      this.receiveAddress = result;\r\n    } else {\r\n      this.changeAddress = result;\r\n    }\r\n\r\n    return result;\r\n    /*\r\n    //even addresses are external, odd address are internal/changes\r\n    for (let counter = 0; counter < addresses.length; counter++) {\r\n      //Internal addresses should be even numbers\r\n      if (external && counter % 2 !== 0) {\r\n        continue;\r\n      }\r\n      //Internal addresses should be odd numbers\r\n      if (external === false && counter % 2 === 0) {\r\n        continue;\r\n      }\r\n      const address = addresses[counter];\r\n\r\n      //If an address has tenth of thousands of transactions, getHistory will throw an exception\r\n\r\n      const hasHistory = await this.hasHistory([address]);\r\n\r\n      if (hasHistory === false) {\r\n        if (external === true) {\r\n          this.receiveAddress = address;\r\n        }\r\n        if (external === false) {\r\n          this.changeAddress = address;\r\n        }\r\n        return address;\r\n      }\r\n    }\r\n*/\r\n  }\r\n\r\n  async getHistory(): Promise<IAddressDelta[]> {\r\n    const assetName = \"\"; //Must be empty string, NOT \"*\"\r\n    const addresses = this.getAddresses();\r\n    const deltas = this.rpc(methods.getaddressdeltas, [\r\n      { addresses, assetName },\r\n    ]);\r\n    //@ts-ignore\r\n    const addressDeltas: IAddressDelta[] = deltas as IAddressDelta[];\r\n    return addressDeltas;\r\n  }\r\n  async getMempool(): Promise<IAddressDelta[]> {\r\n    const method = methods.getaddressmempool;\r\n    const includeAssets = true;\r\n    const params = [{ addresses: this.getAddresses() }, includeAssets];\r\n    return this.rpc(method, params) as Promise<IAddressDelta[]>;\r\n  }\r\n  async getReceiveAddress() {\r\n    const isExternal = true;\r\n    return this._getFirstUnusedAddress(isExternal);\r\n  }\r\n\r\n  async getChangeAddress() {\r\n    const isExternal = false;\r\n    return this._getFirstUnusedAddress(isExternal);\r\n  }\r\n  /**\r\n   *\r\n   * @param assetName if present, only return UTXOs for that asset, otherwise for all assets\r\n   * @returns UTXOs for assets\r\n   */\r\n  async getAssetUTXOs(assetName?: string): Promise<IUTXO[]> {\r\n    //If no asset name, set to wildcard, meaning all assets\r\n    const _assetName = !assetName ? \"*\" : assetName;\r\n    const chainInfo = false;\r\n    const params = [\r\n      { addresses: this.getAddresses(), chainInfo, assetName: _assetName },\r\n    ];\r\n\r\n    return this.rpc(methods.getaddressutxos, params);\r\n  }\r\n  async getUTXOs() {\r\n    return this.rpc(methods.getaddressutxos, [\r\n      { addresses: this.getAddresses() },\r\n    ]);\r\n  }\r\n\r\n  getPrivateKeyByAddress(address: string) {\r\n    const f = this.addressObjects.find((a) => a.address === address);\r\n\r\n    if (!f) {\r\n      return undefined;\r\n    }\r\n    return f.WIF;\r\n  }\r\n\r\n  async send(options: ISend): Promise<ISendResult> {\r\n    //ACTUAL SENDING TRANSACTION\r\n\r\n    //Important, do not swallow the exceptions/errors of createTransaction, let them fly\r\n    const sendResult: ISendResult = await this.createTransaction(options);\r\n\r\n    try {\r\n      const id = await this.rpc(\"sendrawtransaction\", [\r\n        sendResult.debug.signedTransaction,\r\n      ]);\r\n      sendResult.transactionId = id;\r\n\r\n      return sendResult;\r\n    } catch (e) {\r\n      throw new Error(\r\n        \"Error while sending, perhaps you have pending transaction? Please try again.\"\r\n      );\r\n    }\r\n  }\r\n  async sendRawTransaction(raw: string): Promise<string> {\r\n    return this.rpc(\"sendrawtransaction\", [raw]);\r\n  }\r\n\r\n  async sendMany({ outputs, assetName }: ISendManyOptions) {\r\n    const options = {\r\n      wallet: this,\r\n      outputs,\r\n      assetName,\r\n    };\r\n    const sendManyTransaction = new SendManyTransaction(options);\r\n\r\n    return sendManyTransaction;\r\n  }\r\n  /**\r\n   * Does all the heavy lifting regarding creating a transaction\r\n   * but it does not broadcast the actual transaction.\r\n   * Perhaps the user wants to accept the transaction fee?\r\n   * @param options\r\n   * @returns An transaction that has not been broadcasted\r\n   */\r\n  async createTransaction(options: ISend): Promise<ISendResult> {\r\n    const { amount, toAddress } = options;\r\n    let { assetName } = options;\r\n\r\n    if (!assetName) {\r\n      assetName = this.baseCurrency;\r\n    }\r\n\r\n    //Validation\r\n    if (!toAddress) {\r\n      throw Error(\"Wallet.send toAddress is mandatory\");\r\n    }\r\n    if (!amount) {\r\n      throw Error(\"Wallet.send amount is mandatory\");\r\n    }\r\n    const changeAddress = await this.getChangeAddress();\r\n\r\n    if (changeAddress === toAddress) {\r\n      throw new Error(\"Change address cannot be the same as toAddress\");\r\n    }\r\n    const transaction = new Transaction({\r\n      assetName,\r\n      amount,\r\n      toAddress,\r\n      wallet: this,\r\n    });\r\n\r\n    await transaction.loadData();\r\n\r\n    const inputs = transaction.getInputs();\r\n    const outputs = await transaction.getOutputs();\r\n\r\n    const privateKeys = transaction.getPrivateKeys();\r\n\r\n    const raw = await this.rpc(\"createrawtransaction\", [inputs, outputs]);\r\n    const signed = Signer.sign(\r\n      this.network,\r\n      raw,\r\n      transaction.getUTXOs(),\r\n      privateKeys\r\n    );\r\n\r\n    //ACTUAL SENDING TRANSACTION\r\n    try {\r\n      //   const id = await this.rpc(\"sendrawtransaction\", [signed]);\r\n      const sendResult: ISendResult = {\r\n        transactionId: null,\r\n        debug: {\r\n          amount,\r\n          assetName,\r\n          fee: transaction.getFee(),\r\n          inputs,\r\n          outputs,\r\n          privateKeys,\r\n          rawUnsignedTransaction: raw,\r\n          rvnChangeAmount: transaction.getBaseCurrencyChange(),\r\n          rvnAmount: transaction.getBaseCurrencyAmount(),\r\n          signedTransaction: signed,\r\n          UTXOs: transaction.getUTXOs(),\r\n        },\r\n      };\r\n      return sendResult;\r\n    } catch (e) {\r\n      throw new Error(\r\n        \"Error while sending, perhaps you have pending transaction? Please try again.\"\r\n      );\r\n    }\r\n  }\r\n\r\n  async getAssets() {\r\n    const includeAssets = true;\r\n    const params = [{ addresses: this.getAddresses() }, includeAssets];\r\n    const balance = (await this.rpc(methods.getaddressbalance, params)) as any;\r\n\r\n    //Remove baseCurrency\r\n    const result = balance.filter((obj) => {\r\n      return obj.assetName !== this.baseCurrency;\r\n    });\r\n    return result;\r\n  }\r\n  async getBalance() {\r\n    const includeAssets = false;\r\n    const params = [{ addresses: this.getAddresses() }, includeAssets];\r\n    const balance = (await this.rpc(methods.getaddressbalance, params)) as any;\r\n\r\n    return balance.balance / ONE_FULL_COIN;\r\n  }\r\n}\r\n\r\nexport default {\r\n  createInstance,\r\n};\r\nexport async function createInstance(options: IOptions): Promise<Wallet> {\r\n  const wallet = new Wallet();\r\n  await wallet.init(options);\r\n  return wallet;\r\n}\r\n\r\nexport function getBaseCurrencyByNetwork(network: ChainType): string {\r\n  const map = {\r\n    evr: \"EVR\",\r\n    \"evr-test\": \"EVR\",\r\n    rvn: \"RVN\",\r\n    \"rvn-test\": \"RVN\",\r\n  };\r\n  return map[network];\r\n}\r\nexport interface IOptions {\r\n  mnemonic: string;\r\n  minAmountOfAddresses?: number;\r\n  network?: ChainType;\r\n  rpc_username?: string;\r\n  rpc_password?: string;\r\n  rpc_url?: string;\r\n\r\n  offlineMode?: boolean;\r\n}\r\n","export const ONE_FULL_COIN = 1e8;","import RavencoinKey, { Network } from \"@ravenrebels/ravencoin-key\";\r\nimport Signer from \"@ravenrebels/ravencoin-sign-transaction\";\r\n\r\n!!Signer.sign; //\"Idiocracy\" but prevents bundle tools such as PARCEL to strip this dependency out on build.\r\n\r\nimport { Wallet } from \"../ravencoinWallet\";\r\nimport { IInput, SweepResult } from \"../Types\";\r\nimport { shortenNumber } from \"./SendManyTransaction\";\r\n\r\n//sight rate burger maid melody slogan attitude gas account sick awful hammer\r\n//OH easter egg ;)\r\nconst WIF = \"Kz5U4Bmhrng4o2ZgwBi5PjtorCeq2dyM7axGQfdxsBSwCKi5ZfTw\";\r\n\r\n/**\r\n *\r\n * @param WIF the private key in wallet import format that you want to sweep/empty\r\n * @param wallet your wallet\r\n * @returns a string of a signed transaction, you have to broad cast it\r\n */\r\nexport async function sweep(\r\n  WIF: string,\r\n  wallet: Wallet,\r\n  onlineMode: boolean\r\n): Promise<SweepResult> {\r\n  const privateKey = RavencoinKey.getAddressByWIF(wallet.network, WIF);\r\n\r\n  const result: SweepResult = {};\r\n  const rpc = wallet.rpc;\r\n  const obj = {\r\n    addresses: [privateKey.address],\r\n  };\r\n  const baseCurrencyUTXOs = await rpc(\"getaddressutxos\", [obj]);\r\n  const obj2 = {\r\n    addresses: [privateKey.address],\r\n    assetName: \"*\",\r\n  };\r\n\r\n  const assetUTXOs = await rpc(\"getaddressutxos\", [obj2]);\r\n  const UTXOs = assetUTXOs.concat(baseCurrencyUTXOs);\r\n  result.UTXOs = UTXOs;\r\n  //Create a raw transaction with ALL UTXOs\r\n\r\n  if (UTXOs.length === 0) {\r\n    result.errorDescription = \"Address \" + privateKey.address + \" has no funds\";\r\n    return result;\r\n  }\r\n  const balanceObject = {};\r\n\r\n  UTXOs.map((utxo) => {\r\n    if (!balanceObject[utxo.assetName]) {\r\n      balanceObject[utxo.assetName] = 0;\r\n    }\r\n    balanceObject[utxo.assetName] += utxo.satoshis;\r\n  });\r\n\r\n  const keys = Object.keys(balanceObject);\r\n\r\n  //Start simple, get the first addresses from the wallet\r\n\r\n  const outputs = {};\r\n\r\n  const fixedFee = 0.02; // should do for now\r\n  keys.map((assetName, index) => {\r\n    const address = wallet.getAddresses()[index];\r\n    const amount = balanceObject[assetName] / 1e8;\r\n\r\n    if (assetName === wallet.baseCurrency) {\r\n      outputs[address] = shortenNumber(amount - fixedFee);\r\n    } else {\r\n      outputs[address] = {\r\n        transfer: {\r\n          [assetName]: amount,\r\n        },\r\n      };\r\n    }\r\n  });\r\n  result.outputs = outputs;\r\n\r\n  //Convert from UTXO format to INPUT fomat\r\n  const inputs: Array<IInput> = UTXOs.map((utxo, index) => {\r\n    /*   {\r\n         \"txid\":\"id\",                      (string, required) The transaction id\r\n         \"vout\":n,                         (number, required) The output number\r\n         \"sequence\":n                      (number, optional) The sequence number\r\n       } \r\n       */\r\n\r\n    const input: IInput = {\r\n      txid: utxo.txid,\r\n      vout: utxo.outputIndex,\r\n    };\r\n    return input;\r\n  });\r\n  //Create raw transaction\r\n  const rawHex = await rpc(\"createrawtransaction\", [inputs, outputs]);\r\n\r\n  const privateKeys = {\r\n    [privateKey.address]: WIF,\r\n  };\r\n  const signedHex = Signer.sign(wallet.network, rawHex, UTXOs, privateKeys);\r\n  result.rawTransaction = signedHex;\r\n  if (onlineMode === true) {\r\n    result.transactionId = await rpc(\"sendrawtransaction\", [signedHex]);\r\n  }\r\n\r\n  return result;\r\n}\r\n","import { InsufficientFundsError, ValidationError } from \"../Errors\";\r\nimport { Wallet } from \"../ravencoinWallet\";\r\nimport { ISendManyOptions, IUTXO } from \"../Types\";\r\n\r\nexport class SendManyTransaction {\r\n  _allUTXOs: IUTXO[]; //all UTXOs that we know of\r\n\r\n  private assetName: string;\r\n\r\n  feerate = 1; //When loadData is called, this attribute is updated from the blockchain  wallet = null;\r\n\r\n  private wallet: Wallet;\r\n  private outputs: any;\r\n  constructor({ wallet, outputs, assetName }: ISendManyOptions) {\r\n    this.assetName = !assetName ? wallet.baseCurrency : assetName;\r\n    this.wallet = wallet;\r\n    this.outputs = outputs;\r\n  }\r\n\r\n  getSizeInKB() {\r\n    const utxos = this.predictUTXOs();\r\n\r\n    const assumedSizePerUTXO = 300;\r\n    const assumedSizePerOutput = 100;\r\n\r\n    const bytes =\r\n      (utxos.length + 1) * assumedSizePerUTXO +\r\n      Object.keys(this.outputs).length * assumedSizePerOutput;\r\n\r\n    const kb = bytes / 1024;\r\n\r\n    return kb;\r\n  }\r\n  async loadData() {\r\n    //Load blockchain information async, and wait for it\r\n    const mempoolPromise = this.wallet.getMempool();\r\n    const assetUTXOsPromise = this.wallet.getAssetUTXOs();\r\n    const baseCurencyUTXOsPromise = this.wallet.getUTXOs();\r\n    const feeRatePromise = this.getFeeRate();\r\n\r\n    const walletMempool = await mempoolPromise;\r\n    const assetUTXOs = await assetUTXOsPromise;\r\n    const baseCurrencyUTXOs = await baseCurencyUTXOsPromise;\r\n    this.feerate = await feeRatePromise;\r\n\r\n    const mempoolUTXOs = getSpendableMempool(walletMempool);\r\n\r\n    //Decorate mempool UTXOs with script attribute\r\n    for (let u of mempoolUTXOs) {\r\n      if (u.script) {\r\n        continue;\r\n      }\r\n      //Mempool items might not have the script attbribute, we need it\r\n      const utxo = await this.wallet.rpc(\"gettxout\", [u.txid, u.index, true]);\r\n      if (utxo) {\r\n        u.script = utxo.scriptPubKey.hex;\r\n      }\r\n    }\r\n\r\n    const _allUTXOsTemp = assetUTXOs\r\n      .concat(baseCurrencyUTXOs)\r\n      .concat(mempoolUTXOs);\r\n\r\n    //Filter out UTXOs that are NOT in mempool\r\n    const allUTXOs = _allUTXOsTemp.filter((utxo) => {\r\n      const objInMempool = walletMempool.find(\r\n        (mempoolEntry) =>\r\n          mempoolEntry.prevtxid && mempoolEntry.prevtxid === utxo.id\r\n      );\r\n      return !objInMempool;\r\n    });\r\n\r\n    //Sort utxos lowest first\r\n    allUTXOs.sort(sortBySatoshis);\r\n    this._allUTXOs = allUTXOs;\r\n  }\r\n  getAmount() {\r\n    let total = 0;\r\n\r\n    const values: number[] = Object.values(this.outputs);\r\n    values.map((value) => (total += value));\r\n\r\n    return total;\r\n  }\r\n  getUTXOs() {\r\n    if (this.isAssetTransfer() === true) {\r\n      const assetAmount = this.getAmount();\r\n      const baseCurrencyAmount = this.getBaseCurrencyAmount();\r\n\r\n      const baseCurrencyUTXOs = getEnoughUTXOs(\r\n        this._allUTXOs,\r\n        this.wallet.baseCurrency,\r\n        baseCurrencyAmount\r\n      );\r\n      const assetUTXOs = getEnoughUTXOs(\r\n        this._allUTXOs,\r\n        this.assetName,\r\n        assetAmount\r\n      );\r\n\r\n      return assetUTXOs.concat(baseCurrencyUTXOs);\r\n    } else {\r\n      return getEnoughUTXOs(\r\n        this._allUTXOs,\r\n        this.wallet.baseCurrency,\r\n        this.getBaseCurrencyAmount()\r\n      );\r\n    }\r\n  }\r\n\r\n  predictUTXOs() {\r\n    if (this.isAssetTransfer()) {\r\n      return getEnoughUTXOs(this._allUTXOs, this.assetName, this.getAmount());\r\n    }\r\n    return getEnoughUTXOs(\r\n      this._allUTXOs,\r\n      this.wallet.baseCurrency,\r\n      this.getAmount()\r\n    );\r\n  }\r\n  getBaseCurrencyAmount() {\r\n    const fee = this.getFee();\r\n    if (this.isAssetTransfer() === true) {\r\n      return fee;\r\n    } else return this.getAmount() + fee;\r\n  }\r\n  getBaseCurrencyChange() {\r\n    const enoughUTXOs = getEnoughUTXOs(\r\n      this._allUTXOs,\r\n      this.wallet.baseCurrency,\r\n      this.getBaseCurrencyAmount()\r\n    );\r\n\r\n    let total = 0;\r\n    for (let utxo of enoughUTXOs) {\r\n      if (utxo.assetName !== this.wallet.baseCurrency) {\r\n        continue;\r\n      }\r\n      total = total + utxo.satoshis / 1e8;\r\n    }\r\n    const result = total - this.getBaseCurrencyAmount();\r\n    return shortenNumber(result);\r\n  }\r\n  getAssetChange() {\r\n    const enoughUTXOs = getEnoughUTXOs(\r\n      this._allUTXOs,\r\n      this.assetName,\r\n      this.getAmount()\r\n    );\r\n    let total = 0;\r\n    for (let utxo of enoughUTXOs) {\r\n      if (utxo.assetName !== this.assetName) {\r\n        continue;\r\n      }\r\n      total = total + utxo.satoshis / 1e8;\r\n    }\r\n    return total - this.getAmount();\r\n  }\r\n  isAssetTransfer() {\r\n    return this.assetName !== this.wallet.baseCurrency;\r\n  }\r\n\r\n  async getOutputs() {\r\n    //we take the declared outputs and add change outputs\r\n    const totalOutputs = {};\r\n\r\n    if (this.isAssetTransfer() === true) {\r\n      const changeAddressBaseCurrency = await this.wallet.getChangeAddress();\r\n\r\n      //Validate: change address cant be toAddress\r\n      const toAddresses = Object.keys(this.outputs);\r\n      if (toAddresses.includes(changeAddressBaseCurrency) === true) {\r\n        throw new ValidationError(\r\n          \"Change address cannot be the same as to address\"\r\n        );\r\n      }\r\n      totalOutputs[changeAddressBaseCurrency] = this.getBaseCurrencyChange();\r\n\r\n      const index = this.wallet\r\n        .getAddresses()\r\n        .indexOf(changeAddressBaseCurrency);\r\n      const changeAddressAsset = this.wallet.getAddresses()[index + 2];\r\n      //Validate change address can never be the same as toAddress\r\n      if (toAddresses.includes(changeAddressAsset) === true) {\r\n        throw new ValidationError(\r\n          \"Change address cannot be the same as to address\"\r\n        );\r\n      }\r\n      if (this.getAssetChange() > 0) {\r\n        totalOutputs[changeAddressAsset] = {\r\n          transfer: {\r\n            [this.assetName]: this.getAssetChange(),\r\n          },\r\n        };\r\n      }\r\n\r\n      for (let addy of Object.keys(this.outputs)) {\r\n        const amount = this.outputs[addy];\r\n        totalOutputs[addy] = {\r\n          transfer: {\r\n            [this.assetName]: amount,\r\n          },\r\n        };\r\n      }\r\n    } else {\r\n      const changeAddressBaseCurrency = await this.wallet.getChangeAddress();\r\n\r\n      for (let addy of Object.keys(this.outputs)) {\r\n        const amount = this.outputs[addy];\r\n        totalOutputs[addy] = amount;\r\n      }\r\n\r\n      totalOutputs[changeAddressBaseCurrency] = this.getBaseCurrencyChange();\r\n    }\r\n    return totalOutputs;\r\n  }\r\n\r\n  getInputs() {\r\n    return this.getUTXOs().map((obj) => {\r\n      return { address: obj.address, txid: obj.txid, vout: obj.outputIndex };\r\n    });\r\n  }\r\n\r\n  getPrivateKeys() {\r\n    const addressObjects = this.wallet.getAddressObjects();\r\n    const privateKeys = {};\r\n    for (let u of this.getUTXOs()) {\r\n      //Find the address object (we want the WIF) for the address related to the UTXO\r\n      const addressObject = addressObjects.find(\r\n        (obj) => obj.address === u.address\r\n      );\r\n      if (addressObject) {\r\n        privateKeys[u.address] = addressObject.WIF;\r\n      }\r\n    }\r\n    return privateKeys;\r\n  }\r\n\r\n  getFee() {\r\n    const kb = this.getSizeInKB();\r\n\r\n    const result = kb * this.feerate;\r\n\r\n    return result;\r\n  }\r\n  async getFeeRate() {\r\n    const defaultFee = 0.02;\r\n    try {\r\n      const confirmationTarget = 20;\r\n      const asdf = await this.wallet.rpc(\"estimatesmartfee\", [\r\n        confirmationTarget,\r\n      ]);\r\n      if (!asdf.errors) {\r\n        return asdf.feerate;\r\n      } else {\r\n        return defaultFee;\r\n      }\r\n    } catch (e) {\r\n      //Might occure errors on testnet when calculating fees\r\n      return defaultFee;\r\n    }\r\n  }\r\n}\r\n\r\n//Return the number with max 2 decimals\r\nexport function shortenNumber(number) {\r\n  return parseFloat(number.toFixed(2));\r\n}\r\n\r\nfunction sortBySatoshis(u1, u2) {\r\n  if (u1.satoshis > u2.satoshis) {\r\n    return 1;\r\n  }\r\n  if (u1.satoshis === u2.satoshis) {\r\n    return 0;\r\n  }\r\n  return -1;\r\n}\r\n\r\nfunction getEnoughUTXOs(\r\n  utxos: IUTXO[],\r\n  asset: string,\r\n  amount: number\r\n): IUTXO[] {\r\n  const result: IUTXO[] = [];\r\n  let sum = 0;\r\n  for (let u of utxos) {\r\n    if (sum > amount) {\r\n      break;\r\n    }\r\n    if (u.assetName !== asset) {\r\n      continue;\r\n    }\r\n    //Ignore UTXOs with zero satoshis, seems to occure when assets are minted\r\n    if (u.satoshis === 0) {\r\n      continue;\r\n    }\r\n    const value = u.satoshis / 1e8;\r\n    result.push(u);\r\n    sum = sum + value;\r\n  }\r\n\r\n  if (sum < amount) {\r\n    const error = new InsufficientFundsError(\r\n      \"You do not have \" + amount + \" \" + asset + \" you only have \" + sum\r\n    );\r\n\r\n    throw error;\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction getSpendableMempool(mempool) {\r\n  /*\r\ninterface IUTXO {\r\n   address: string;\r\n   assetName: string;\r\n   txid: string;\r\n   outputIndex: number;\r\n   script: string;\r\n   satoshis: number;\r\n   height: number;\r\n   value: number;\r\n}\r\n*/\r\n\r\n  const mySet = new Set();\r\n\r\n  for (let item of mempool) {\r\n    if (!item.prevtxid) {\r\n      continue;\r\n    }\r\n    const value = item.prevtxid + \"_\" + item.prevout;\r\n    mySet.add(value);\r\n  }\r\n\r\n  const spendable = mempool.filter((item) => {\r\n    if (item.satoshis < 0) {\r\n      return false;\r\n    }\r\n    const value = item.txid + \"_\" + item.index;\r\n    return mySet.has(value) === false;\r\n  });\r\n\r\n  //UTXO object need to have an outputIndex property, not index\r\n  spendable.map((s) => (s.outputIndex = s.index));\r\n  return spendable;\r\n}\r\n","export class ValidationError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = \"ValidationError\";\r\n  }\r\n}\r\nexport class InvalidAddressError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = \"InvalidAddressError\";\r\n  }\r\n}\r\n\r\nexport class InsufficientFundsError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = \"InsufficientFundsError\";\r\n  }\r\n}\r\n","import { InsufficientFundsError, ValidationError } from \"../Errors\";\r\nimport { Wallet } from \"../ravencoinWallet\";\r\nimport { ISendManyOptions, ISendOptions } from \"../Types\";\r\nimport { SendManyTransaction } from \"./SendManyTransaction\";\r\n\r\n\r\nexport class Transaction {\r\n  private sendManyTransaction: SendManyTransaction;\r\n\r\n  constructor({ wallet, toAddress, amount, assetName }: ISendOptions) {\r\n    const options: ISendManyOptions = {\r\n      assetName,\r\n      wallet,\r\n      outputs: {\r\n        [toAddress]: amount,\r\n      },\r\n    };\r\n    this.sendManyTransaction = new SendManyTransaction(options);\r\n  }\r\n\r\n  getSizeInKB() {\r\n    return this.sendManyTransaction.getSizeInKB();\r\n  }\r\n  async loadData() {\r\n    return this.sendManyTransaction.loadData();\r\n  }\r\n  getUTXOs() {\r\n    return this.sendManyTransaction.getUTXOs();\r\n  }\r\n\r\n  predictUTXOs() {\r\n    return this.sendManyTransaction.predictUTXOs();\r\n  }\r\n  getBaseCurrencyAmount() {\r\n    return this.sendManyTransaction.getBaseCurrencyAmount();\r\n  }\r\n  getBaseCurrencyChange() {\r\n    return this.sendManyTransaction.getBaseCurrencyChange();\r\n  }\r\n  getAssetChange() {\r\n    return this.sendManyTransaction.getAssetChange();\r\n  }\r\n  isAssetTransfer() {\r\n    return this.sendManyTransaction.isAssetTransfer();\r\n  }\r\n\r\n  async getOutputs() {\r\n    return this.sendManyTransaction.getOutputs();\r\n  }\r\n\r\n  getInputs() {\r\n    return this.sendManyTransaction.getInputs();\r\n  }\r\n\r\n  getPrivateKeys() {\r\n    return this.sendManyTransaction.getPrivateKeys();\r\n  }\r\n\r\n  getFee() {\r\n    return this.sendManyTransaction.getFee();\r\n  }\r\n  async getFeeRate() {\r\n    return this.sendManyTransaction.getFeeRate();\r\n  }\r\n}\r\n"],"names":[],"version":3,"file":"index.mjs.map"}